//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountsClient {
    getAll(query: GetAccountsListQuery): Observable<PaginatedResponseOfAccountModel>;
    get(id: string): Observable<AccountModel>;
    create(command: CreateAccountCommand): Observable<string>;
    update(command: UpdateAccountCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    login(command: LoginRequestCommand): Observable<AuthenticatedResponse>;
    refreshToken(): Observable<AuthenticatedResponse>;
    logout(): Observable<void>;
    changePassword(command: ChangePasswordCommand): Observable<void>;
    getUserPermissions(allowCache: boolean | undefined): Observable<string[]>;
}

@Injectable()
export class AccountsClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetAccountsListQuery): Observable<PaginatedResponseOfAccountModel> {
        let url_ = this.baseUrl + "/api/Accounts/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfAccountModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfAccountModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfAccountModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfAccountModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<AccountModel> {
        let url_ = this.baseUrl + "/api/Accounts/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAccountCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Accounts/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateAccountCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(command: LoginRequestCommand): Observable<AuthenticatedResponse> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticatedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticatedResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticatedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(): Observable<AuthenticatedResponse> {
        let url_ = this.baseUrl + "/api/Accounts/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticatedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticatedResponse>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<AuthenticatedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(command: ChangePasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserPermissions(allowCache: boolean | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Accounts/GetUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(allowCache);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetUserPermissions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMoneyTransfersClient {
    getAll(query: GetMoneyTransfersListQuery): Observable<PaginatedResponseOfMoneyTransferModel>;
    get(id: string): Observable<MoneyTransferModel>;
    create(command: CreateMoneyTransferCommand): Observable<string>;
    update(command: UpdateMoneyTransferCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class MoneyTransfersClient implements IMoneyTransfersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetMoneyTransfersListQuery): Observable<PaginatedResponseOfMoneyTransferModel> {
        let url_ = this.baseUrl + "/api/MoneyTransfers/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfMoneyTransferModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfMoneyTransferModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfMoneyTransferModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfMoneyTransferModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<MoneyTransferModel> {
        let url_ = this.baseUrl + "/api/MoneyTransfers/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MoneyTransferModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MoneyTransferModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MoneyTransferModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MoneyTransferModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateMoneyTransferCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/MoneyTransfers/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateMoneyTransferCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/MoneyTransfers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/MoneyTransfers/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/MoneyTransfers/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IImagesClient {
    images(fileName: string): Observable<void>;
}

@Injectable()
export class ImagesClient implements IImagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    images(fileName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Images/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISelectListsClient {
    getLookupSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]>;
    getLookupDetailSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]>;
    getRoleSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]>;
    getMenuTypeSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]>;
}

@Injectable()
export class SelectListsClient implements ISelectListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getLookupSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]> {
        let url_ = this.baseUrl + "/api/SelectLists/GetLookupSelectList?";
        if (allowCache !== undefined && allowCache !== null)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListModel[]>;
        }));
    }

    protected processGetLookupSelectList(response: HttpResponseBase): Observable<SelectListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLookupDetailSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]> {
        let url_ = this.baseUrl + "/api/SelectLists/GetLookupDetailSelectList?";
        if (allowCache !== undefined && allowCache !== null)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupDetailSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupDetailSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListModel[]>;
        }));
    }

    protected processGetLookupDetailSelectList(response: HttpResponseBase): Observable<SelectListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoleSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]> {
        let url_ = this.baseUrl + "/api/SelectLists/GetRoleSelectList?";
        if (allowCache !== undefined && allowCache !== null)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListModel[]>;
        }));
    }

    protected processGetRoleSelectList(response: HttpResponseBase): Observable<SelectListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMenuTypeSelectList(allowCache: boolean | null | undefined): Observable<SelectListModel[]> {
        let url_ = this.baseUrl + "/api/SelectLists/GetMenuTypeSelectList?";
        if (allowCache !== undefined && allowCache !== null)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuTypeSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuTypeSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListModel[]>;
        }));
    }

    protected processGetMenuTypeSelectList(response: HttpResponseBase): Observable<SelectListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomerGroupsClient {
    getAll(query: GetCustomerGroupListQuery): Observable<PaginatedResponseOfCustomerGroupModel>;
    get(id: string): Observable<CustomerGroupModel>;
    create(command: CreateCustomerGroupCommand): Observable<string>;
    update(command: UpdateCustomerGroupCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class CustomerGroupsClient implements ICustomerGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetCustomerGroupListQuery): Observable<PaginatedResponseOfCustomerGroupModel> {
        let url_ = this.baseUrl + "/api/CustomerGroups/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfCustomerGroupModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfCustomerGroupModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfCustomerGroupModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfCustomerGroupModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CustomerGroupModel> {
        let url_ = this.baseUrl + "/api/CustomerGroups/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerGroupModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerGroupModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerGroupModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerGroupModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerGroupCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CustomerGroups/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCustomerGroupCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/CustomerGroups/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/CustomerGroups/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/CustomerGroups/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomersClient {
    getAll(query: GetCustomerListQuery): Observable<PaginatedResponseOfCustomerModel>;
    get(id: string): Observable<CustomerModel>;
    create(command: CreateCustomerCommand): Observable<string>;
    update(command: UpdateCustomerCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
}

@Injectable()
export class CustomersClient implements ICustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetCustomerListQuery): Observable<PaginatedResponseOfCustomerModel> {
        let url_ = this.baseUrl + "/api/Customers/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfCustomerModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfCustomerModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfCustomerModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfCustomerModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CustomerModel> {
        let url_ = this.baseUrl + "/api/Customers/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Customers/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/Customers/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISuppliersClient {
    getAll(query: GetSupplierListQuery): Observable<PaginatedResponseOfSupplierModel>;
    get(id: string): Observable<SupplierModel>;
    create(command: CreateSupplierCommand): Observable<string>;
    update(command: UpdateSupplierCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
}

@Injectable()
export class SuppliersClient implements ISuppliersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetSupplierListQuery): Observable<PaginatedResponseOfSupplierModel> {
        let url_ = this.baseUrl + "/api/Suppliers/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfSupplierModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfSupplierModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfSupplierModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfSupplierModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<SupplierModel> {
        let url_ = this.baseUrl + "/api/Suppliers/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SupplierModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSupplierCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Suppliers/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateSupplierCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Suppliers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Suppliers/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Suppliers/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/Suppliers/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITreeNodeListsClient {
    getAllPermissionNodeList(allowCache: boolean | null | undefined): Observable<DynamicTreeNodeModel[]>;
    getAllAppMenuTreeSelectList(allowCache: boolean | null | undefined): Observable<TreeNodeModel[]>;
}

@Injectable()
export class TreeNodeListsClient implements ITreeNodeListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllPermissionNodeList(allowCache: boolean | null | undefined): Observable<DynamicTreeNodeModel[]> {
        let url_ = this.baseUrl + "/api/TreeNodeLists/GetAllPermissionNodeList?";
        if (allowCache !== undefined && allowCache !== null)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionNodeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionNodeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicTreeNodeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicTreeNodeModel[]>;
        }));
    }

    protected processGetAllPermissionNodeList(response: HttpResponseBase): Observable<DynamicTreeNodeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicTreeNodeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllAppMenuTreeSelectList(allowCache: boolean | null | undefined): Observable<TreeNodeModel[]> {
        let url_ = this.baseUrl + "/api/TreeNodeLists/GetAllAppMenuTreeSelectList?";
        if (allowCache !== undefined && allowCache !== null)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppMenuTreeSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppMenuTreeSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeModel[]>;
        }));
    }

    protected processGetAllAppMenuTreeSelectList(response: HttpResponseBase): Observable<TreeNodeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICompanyInfosClient {
    get(): Observable<CompanyInfoModel>;
    create(command: CreateCompanyInfoCommand): Observable<string>;
    update(command: UpdateCompanyInfoCommand): Observable<void>;
}

@Injectable()
export class CompanyInfosClient implements ICompanyInfosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    get(): Observable<CompanyInfoModel> {
        let url_ = this.baseUrl + "/api/CompanyInfos/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyInfoModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCompanyInfoCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CompanyInfos/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCompanyInfoCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/CompanyInfos/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISaleReturnsClient {
    getAll(query: GetSaleReturnListQuery): Observable<PaginatedResponseOfSaleReturnModel>;
    get(id: string): Observable<UpsertSaleReturnModel>;
    getBySaleId(saleId: string): Observable<UpsertSaleReturnModel>;
    getDetail(id: string): Observable<SaleReturnInfoModel>;
    create(command: CreateSaleReturnCommand): Observable<string>;
    update(command: UpdateSaleReturnCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    deleteSaleReturnDetail(id: string): Observable<void>;
}

@Injectable()
export class SaleReturnsClient implements ISaleReturnsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetSaleReturnListQuery): Observable<PaginatedResponseOfSaleReturnModel> {
        let url_ = this.baseUrl + "/api/SaleReturns/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfSaleReturnModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfSaleReturnModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfSaleReturnModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfSaleReturnModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<UpsertSaleReturnModel> {
        let url_ = this.baseUrl + "/api/SaleReturns/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpsertSaleReturnModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpsertSaleReturnModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UpsertSaleReturnModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpsertSaleReturnModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBySaleId(saleId: string): Observable<UpsertSaleReturnModel> {
        let url_ = this.baseUrl + "/api/SaleReturns/GetBySaleId/{saleId}";
        if (saleId === undefined || saleId === null)
            throw new Error("The parameter 'saleId' must be defined.");
        url_ = url_.replace("{saleId}", encodeURIComponent("" + saleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySaleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySaleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpsertSaleReturnModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpsertSaleReturnModel>;
        }));
    }

    protected processGetBySaleId(response: HttpResponseBase): Observable<UpsertSaleReturnModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpsertSaleReturnModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetail(id: string): Observable<SaleReturnInfoModel> {
        let url_ = this.baseUrl + "/api/SaleReturns/GetDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleReturnInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleReturnInfoModel>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<SaleReturnInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleReturnInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSaleReturnCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/SaleReturns/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateSaleReturnCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/SaleReturns/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/SaleReturns/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/SaleReturns/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSaleReturnDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/SaleReturns/DeleteSaleReturnDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSaleReturnDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSaleReturnDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSaleReturnDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICouponsClient {
    getAll(query: GetCouponListQuery): Observable<PaginatedResponseOfCouponModel>;
    get(id: string): Observable<CouponModel>;
    create(command: CreateCouponCommand): Observable<string>;
    update(command: UpdateCouponCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class CouponsClient implements ICouponsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetCouponListQuery): Observable<PaginatedResponseOfCouponModel> {
        let url_ = this.baseUrl + "/api/Coupons/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfCouponModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfCouponModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfCouponModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfCouponModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CouponModel> {
        let url_ = this.baseUrl + "/api/Coupons/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CouponModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCouponCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Coupons/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCouponCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Coupons/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Coupons/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Coupons/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICouriersClient {
    getAll(query: GetCourierListQuery): Observable<PaginatedResponseOfCourierModel>;
    get(id: string): Observable<CourierModel>;
    create(command: CreateCourierCommand): Observable<string>;
    update(command: UpdateCourierCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class CouriersClient implements ICouriersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetCourierListQuery): Observable<PaginatedResponseOfCourierModel> {
        let url_ = this.baseUrl + "/api/Couriers/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfCourierModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfCourierModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfCourierModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfCourierModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CourierModel> {
        let url_ = this.baseUrl + "/api/Couriers/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourierModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourierModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CourierModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourierModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCourierCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Couriers/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCourierCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Couriers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Couriers/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Couriers/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGiftCardsClient {
    getAll(query: GetGiftCardListQuery): Observable<PaginatedResponseOfGiftCardModel>;
    get(id: string): Observable<GiftCardModel>;
    create(command: CreateGiftCardCommand): Observable<string>;
    update(command: UpdateGiftCardCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class GiftCardsClient implements IGiftCardsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetGiftCardListQuery): Observable<PaginatedResponseOfGiftCardModel> {
        let url_ = this.baseUrl + "/api/GiftCards/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfGiftCardModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfGiftCardModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfGiftCardModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfGiftCardModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<GiftCardModel> {
        let url_ = this.baseUrl + "/api/GiftCards/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GiftCardModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GiftCardModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GiftCardModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GiftCardModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateGiftCardCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/GiftCards/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateGiftCardCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/GiftCards/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/GiftCards/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/GiftCards/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISalePaymentsClient {
    getAll(query: GetSalePaymentListQuery): Observable<PaginatedResponseOfSalePaymentModel>;
    getAllBySaleId(query: GetPaymentListBySaleIdQuery): Observable<SalePaymentModel[]>;
    get(id: string): Observable<SalePaymentModel>;
    create(command: CreateSalePaymentCommand): Observable<string>;
    update(command: UpdateSalePaymentCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class SalePaymentsClient implements ISalePaymentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetSalePaymentListQuery): Observable<PaginatedResponseOfSalePaymentModel> {
        let url_ = this.baseUrl + "/api/SalePayments/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfSalePaymentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfSalePaymentModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfSalePaymentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfSalePaymentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllBySaleId(query: GetPaymentListBySaleIdQuery): Observable<SalePaymentModel[]> {
        let url_ = this.baseUrl + "/api/SalePayments/GetAllBySaleId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBySaleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBySaleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalePaymentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalePaymentModel[]>;
        }));
    }

    protected processGetAllBySaleId(response: HttpResponseBase): Observable<SalePaymentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalePaymentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<SalePaymentModel> {
        let url_ = this.baseUrl + "/api/SalePayments/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalePaymentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalePaymentModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalePaymentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalePaymentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSalePaymentCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/SalePayments/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateSalePaymentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/SalePayments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/SalePayments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/SalePayments/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISalesClient {
    getAll(query: GetSaleListQuery): Observable<PaginatedResponseOfSaleModel>;
    get(id: string): Observable<UpsertSaleModel>;
    getDetail(id: string): Observable<SaleInfoModel>;
    create(command: CreateSaleCommand): Observable<string>;
    update(command: UpdateSaleCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    deleteSaleDetail(id: string): Observable<void>;
}

@Injectable()
export class SalesClient implements ISalesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetSaleListQuery): Observable<PaginatedResponseOfSaleModel> {
        let url_ = this.baseUrl + "/api/Sales/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfSaleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfSaleModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfSaleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfSaleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<UpsertSaleModel> {
        let url_ = this.baseUrl + "/api/Sales/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpsertSaleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpsertSaleModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UpsertSaleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpsertSaleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetail(id: string): Observable<SaleInfoModel> {
        let url_ = this.baseUrl + "/api/Sales/GetDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleInfoModel>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<SaleInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSaleCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Sales/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateSaleCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Sales/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Sales/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Sales/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSaleDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Sales/DeleteSaleDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSaleDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSaleDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSaleDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuotationsClient {
    getAll(query: GetQuotationListQuery): Observable<PaginatedResponseOfQuotationModel>;
    get(id: string): Observable<UpsertQuotationModel>;
    getDetail(id: string): Observable<QuotationInfoModel>;
    create(command: CreateQuotationCommand): Observable<string>;
    update(command: UpdateQuotationCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    deleteQuotationDetail(id: string): Observable<void>;
}

@Injectable()
export class QuotationsClient implements IQuotationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetQuotationListQuery): Observable<PaginatedResponseOfQuotationModel> {
        let url_ = this.baseUrl + "/api/Quotations/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfQuotationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfQuotationModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfQuotationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfQuotationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<UpsertQuotationModel> {
        let url_ = this.baseUrl + "/api/Quotations/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpsertQuotationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpsertQuotationModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UpsertQuotationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpsertQuotationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetail(id: string): Observable<QuotationInfoModel> {
        let url_ = this.baseUrl + "/api/Quotations/GetDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuotationInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuotationInfoModel>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<QuotationInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuotationInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateQuotationCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Quotations/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateQuotationCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Quotations/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Quotations/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Quotations/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuotationDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Quotations/DeleteQuotationDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuotationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuotationDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteQuotationDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPurchaseReturnsClient {
    getAll(query: GetPurchaseReturnListQuery): Observable<PaginatedResponseOfPurchaseReturnModel>;
    get(id: string): Observable<PurchaseReturnModel>;
    getByPurchaseId(purchaseId: string): Observable<PurchaseReturnModel>;
    getDetail(id: string): Observable<PurchaseReturnInfoModel>;
    create(command: CreatePurchaseReturnCommand): Observable<string>;
    update(command: UpdatePurchaseReturnCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
    deletePurchaseReturnDetail(id: string): Observable<void>;
}

@Injectable()
export class PurchaseReturnsClient implements IPurchaseReturnsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetPurchaseReturnListQuery): Observable<PaginatedResponseOfPurchaseReturnModel> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfPurchaseReturnModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfPurchaseReturnModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfPurchaseReturnModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfPurchaseReturnModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<PurchaseReturnModel> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseReturnModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseReturnModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchaseReturnModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseReturnModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPurchaseId(purchaseId: string): Observable<PurchaseReturnModel> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/GetByPurchaseId/{purchaseId}";
        if (purchaseId === undefined || purchaseId === null)
            throw new Error("The parameter 'purchaseId' must be defined.");
        url_ = url_.replace("{purchaseId}", encodeURIComponent("" + purchaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPurchaseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPurchaseId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseReturnModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseReturnModel>;
        }));
    }

    protected processGetByPurchaseId(response: HttpResponseBase): Observable<PurchaseReturnModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseReturnModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetail(id: string): Observable<PurchaseReturnInfoModel> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/GetDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseReturnInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseReturnInfoModel>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<PurchaseReturnInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseReturnInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePurchaseReturnCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdatePurchaseReturnCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePurchaseReturnDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchaseReturns/DeletePurchaseReturnDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurchaseReturnDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurchaseReturnDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePurchaseReturnDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPurchasePaymentsClient {
    getAll(query: GetPurchasePaymentListQuery): Observable<PaginatedResponseOfPurchasePaymentModel>;
    getAllByPurchaseId(query: GetPaymentListByPurchaseIdQuery): Observable<PurchasePaymentModel[]>;
    get(id: string): Observable<PurchasePaymentModel>;
    create(command: CreatePurchasePaymentCommand): Observable<string>;
    update(command: UpdatePurchasePaymentCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class PurchasePaymentsClient implements IPurchasePaymentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetPurchasePaymentListQuery): Observable<PaginatedResponseOfPurchasePaymentModel> {
        let url_ = this.baseUrl + "/api/PurchasePayments/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfPurchasePaymentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfPurchasePaymentModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfPurchasePaymentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfPurchasePaymentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllByPurchaseId(query: GetPaymentListByPurchaseIdQuery): Observable<PurchasePaymentModel[]> {
        let url_ = this.baseUrl + "/api/PurchasePayments/GetAllByPurchaseId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPurchaseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPurchaseId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasePaymentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasePaymentModel[]>;
        }));
    }

    protected processGetAllByPurchaseId(response: HttpResponseBase): Observable<PurchasePaymentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PurchasePaymentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<PurchasePaymentModel> {
        let url_ = this.baseUrl + "/api/PurchasePayments/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasePaymentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasePaymentModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchasePaymentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchasePaymentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePurchasePaymentCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/PurchasePayments/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdatePurchasePaymentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchasePayments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchasePayments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/PurchasePayments/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPurchasesClient {
    getAll(query: GetPurchaseListQuery): Observable<PaginatedResponseOfPurchaseModel>;
    get(id: string): Observable<PurchaseModel>;
    getDetail(id: string): Observable<PurchaseInfoModel>;
    create(command: CreatePurchaseCommand): Observable<string>;
    update(command: UpdatePurchaseCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
    deletePurchaseDetail(id: string): Observable<void>;
}

@Injectable()
export class PurchasesClient implements IPurchasesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetPurchaseListQuery): Observable<PaginatedResponseOfPurchaseModel> {
        let url_ = this.baseUrl + "/api/Purchases/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfPurchaseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfPurchaseModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfPurchaseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfPurchaseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<PurchaseModel> {
        let url_ = this.baseUrl + "/api/Purchases/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchaseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetail(id: string): Observable<PurchaseInfoModel> {
        let url_ = this.baseUrl + "/api/Purchases/GetDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseInfoModel>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<PurchaseInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePurchaseCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Purchases/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdatePurchaseCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Purchases/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Purchases/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Purchases/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/Purchases/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePurchaseDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Purchases/DeletePurchaseDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurchaseDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurchaseDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePurchaseDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductTransfersClient {
    getAll(query: GetProductTransferListQuery): Observable<PaginatedResponseOfProductTransferModel>;
    get(id: string): Observable<ProductTransferModel>;
    getDetail(id: string): Observable<ProductTransferInfoModel>;
    create(command: CreateProductTransferCommand): Observable<string>;
    update(command: UpdateProductTransferCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
    deleteProductTransferDetail(id: string): Observable<void>;
}

@Injectable()
export class ProductTransfersClient implements IProductTransfersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetProductTransferListQuery): Observable<PaginatedResponseOfProductTransferModel> {
        let url_ = this.baseUrl + "/api/ProductTransfers/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfProductTransferModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfProductTransferModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfProductTransferModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfProductTransferModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<ProductTransferModel> {
        let url_ = this.baseUrl + "/api/ProductTransfers/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTransferModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTransferModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductTransferModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTransferModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDetail(id: string): Observable<ProductTransferInfoModel> {
        let url_ = this.baseUrl + "/api/ProductTransfers/GetDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTransferInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTransferInfoModel>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ProductTransferInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTransferInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductTransferCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/ProductTransfers/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductTransferCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductTransfers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductTransfers/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductTransfers/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductTransfers/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteProductTransferDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductTransfers/DeleteProductTransferDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductTransferDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductTransferDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteProductTransferDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBrandsClient {
    getAll(query: GetBrandListQuery): Observable<PaginatedResponseOfBrandModel>;
    get(id: string): Observable<BrandModel>;
    create(command: CreateBrandCommand): Observable<string>;
    update(command: UpdateBrandCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class BrandsClient implements IBrandsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetBrandListQuery): Observable<PaginatedResponseOfBrandModel> {
        let url_ = this.baseUrl + "/api/Brands/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfBrandModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfBrandModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfBrandModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfBrandModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<BrandModel> {
        let url_ = this.baseUrl + "/api/Brands/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BrandModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateBrandCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Brands/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateBrandCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Brands/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Brands/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Brands/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICategoriesClient {
    getAll(query: GetCategoryListQuery): Observable<PaginatedResponseOfCategoryModel>;
    get(id: string): Observable<CategoryModel>;
    create(command: CreateCategoryCommand): Observable<string>;
    update(command: UpdateCategoryCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
}

@Injectable()
export class CategoriesClient implements ICategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetCategoryListQuery): Observable<PaginatedResponseOfCategoryModel> {
        let url_ = this.baseUrl + "/api/Categories/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfCategoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfCategoryModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfCategoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfCategoryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CategoryModel> {
        let url_ = this.baseUrl + "/api/Categories/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CategoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCategoryCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Categories/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCategoryCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Categories/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/Categories/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountStocksClient {
    getAll(query: GetCountStockListQuery): Observable<PaginatedResponseOfCountStockModel>;
    get(id: string): Observable<CountStockModel>;
    create(command: CreateCountStockCommand): Observable<string>;
    update(command: UpdateCountStockCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class CountStocksClient implements ICountStocksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetCountStockListQuery): Observable<PaginatedResponseOfCountStockModel> {
        let url_ = this.baseUrl + "/api/CountStocks/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfCountStockModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfCountStockModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfCountStockModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfCountStockModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CountStockModel> {
        let url_ = this.baseUrl + "/api/CountStocks/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountStockModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountStockModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CountStockModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountStockModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCountStockCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CountStocks/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCountStockCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/CountStocks/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/CountStocks/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/CountStocks/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductAdjustmentsClient {
    getAll(query: GetProductAdjustmentListQuery): Observable<PaginatedResponseOfProductAdjustmentModel>;
    get(id: string): Observable<ProductAdjustmentModel>;
    create(command: CreateProductAdjustmentCommand): Observable<string>;
    update(command: UpdateProductAdjustmentCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    deleteAdjDetail(id: string): Observable<void>;
}

@Injectable()
export class ProductAdjustmentsClient implements IProductAdjustmentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetProductAdjustmentListQuery): Observable<PaginatedResponseOfProductAdjustmentModel> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfProductAdjustmentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfProductAdjustmentModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfProductAdjustmentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfProductAdjustmentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<ProductAdjustmentModel> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAdjustmentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAdjustmentModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductAdjustmentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAdjustmentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAdjustmentCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductAdjustmentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAdjDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ProductAdjustments/DeleteAdjDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdjDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdjDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAdjDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductsClient {
    getAll(query: GetProductListQuery): Observable<PaginatedResponseOfProductModel>;
    get(id: string): Observable<ProductModel>;
    create(command: CreateProductCommand): Observable<string>;
    update(command: UpdateProductCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
    getProductSelectList(allowCache: boolean | undefined): Observable<ProductSelectListModel[]>;
}

@Injectable()
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetProductListQuery): Observable<PaginatedResponseOfProductModel> {
        let url_ = this.baseUrl + "/api/Products/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfProductModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfProductModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfProductModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfProductModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<ProductModel> {
        let url_ = this.baseUrl + "/api/Products/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Products/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Products/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Products/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Products/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/Products/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductSelectList(allowCache: boolean | undefined): Observable<ProductSelectListModel[]> {
        let url_ = this.baseUrl + "/api/Products/GetProductSelectList?";
        if (allowCache === null)
            throw new Error("The parameter 'allowCache' cannot be null.");
        else if (allowCache !== undefined)
            url_ += "allowCache=" + encodeURIComponent("" + allowCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSelectListModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSelectListModel[]>;
        }));
    }

    protected processGetProductSelectList(response: HttpResponseBase): Observable<ProductSelectListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSelectListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITaxesClient {
    getAll(query: GetTaxListQuery): Observable<PaginatedResponseOfTaxModel>;
    get(id: string): Observable<TaxModel>;
    create(command: CreateTaxCommand): Observable<string>;
    update(command: UpdateTaxCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class TaxesClient implements ITaxesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetTaxListQuery): Observable<PaginatedResponseOfTaxModel> {
        let url_ = this.baseUrl + "/api/Taxes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfTaxModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfTaxModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfTaxModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfTaxModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<TaxModel> {
        let url_ = this.baseUrl + "/api/Taxes/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TaxModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTaxCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Taxes/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateTaxCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Taxes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Taxes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Taxes/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUnitsClient {
    getAll(query: GetUnitListQuery): Observable<PaginatedResponseOfUnitModel>;
    get(id: string): Observable<UnitModel>;
    create(command: CreateUnitCommand): Observable<string>;
    update(command: UpdateUnitCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class UnitsClient implements IUnitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetUnitListQuery): Observable<PaginatedResponseOfUnitModel> {
        let url_ = this.baseUrl + "/api/Units/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfUnitModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfUnitModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfUnitModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfUnitModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<UnitModel> {
        let url_ = this.baseUrl + "/api/Units/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UnitModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUnitCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Units/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateUnitCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Units/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Units/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Units/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWarehousesClient {
    getAll(query: GetWarehouseListQuery): Observable<PaginatedResponseOfWarehouseModel>;
    get(id: string): Observable<WarehouseModel>;
    create(command: CreateWarehouseCommand): Observable<string>;
    update(command: UpdateWarehouseCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
}

@Injectable()
export class WarehousesClient implements IWarehousesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetWarehouseListQuery): Observable<PaginatedResponseOfWarehouseModel> {
        let url_ = this.baseUrl + "/api/Warehouses/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfWarehouseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfWarehouseModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfWarehouseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfWarehouseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<WarehouseModel> {
        let url_ = this.baseUrl + "/api/Warehouses/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WarehouseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateWarehouseCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Warehouses/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateWarehouseCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Warehouses/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Warehouses/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Warehouses/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/Warehouses/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILookupDetailsClient {
    getAll(query: GetLookupDetailListQuery): Observable<PaginatedResponseOfLookupDetailModel>;
    get(id: string): Observable<LookupDetailModel>;
    create(command: CreateLookupDetailCommand): Observable<string>;
    update(command: UpdateLookupDetailCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
    upload(): Observable<number>;
}

@Injectable()
export class LookupDetailsClient implements ILookupDetailsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetLookupDetailListQuery): Observable<PaginatedResponseOfLookupDetailModel> {
        let url_ = this.baseUrl + "/api/LookupDetails/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfLookupDetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfLookupDetailModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfLookupDetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfLookupDetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<LookupDetailModel> {
        let url_ = this.baseUrl + "/api/LookupDetails/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDetailModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LookupDetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupDetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateLookupDetailCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/LookupDetails/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateLookupDetailCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/LookupDetails/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/LookupDetails/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/LookupDetails/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upload(): Observable<number> {
        let url_ = this.baseUrl + "/api/LookupDetails/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILookupsClient {
    getAll(query: GetLookupListQuery): Observable<PaginatedResponseOfLookupModel>;
    get(id: string): Observable<LookupModel>;
    create(command: CreateLookupCommand): Observable<string>;
    update(command: UpdateLookupCommand): Observable<void>;
    delete(id: string): Observable<void>;
}

@Injectable()
export class LookupsClient implements ILookupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetLookupListQuery): Observable<PaginatedResponseOfLookupModel> {
        let url_ = this.baseUrl + "/api/Lookups/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfLookupModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfLookupModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfLookupModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfLookupModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<LookupModel> {
        let url_ = this.baseUrl + "/api/Lookups/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LookupModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateLookupCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Lookups/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateLookupCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Lookups/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Lookups/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAppMenusClient {
    getAll(query: GetAppMenuListQuery): Observable<PaginatedResponseOfAppMenuModel>;
    getSidebarMenus(): Observable<SidebarMenuModel[]>;
    get(id: string): Observable<AppMenuModel>;
    create(command: CreateAppMenuCommand): Observable<string>;
    update(command: UpdateAppMenuCommand): Observable<void>;
    delete(id: string): Observable<void>;
    getAllMenuAsTree(): Observable<TreeNodeModel[]>;
    reorderAppMenus(command: UpdateAppMenuOrderCommand): Observable<void>;
}

@Injectable()
export class AppMenusClient implements IAppMenusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetAppMenuListQuery): Observable<PaginatedResponseOfAppMenuModel> {
        let url_ = this.baseUrl + "/api/AppMenus/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfAppMenuModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfAppMenuModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfAppMenuModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfAppMenuModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSidebarMenus(): Observable<SidebarMenuModel[]> {
        let url_ = this.baseUrl + "/api/AppMenus/GetSidebarMenus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSidebarMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSidebarMenus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SidebarMenuModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SidebarMenuModel[]>;
        }));
    }

    protected processGetSidebarMenus(response: HttpResponseBase): Observable<SidebarMenuModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SidebarMenuModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<AppMenuModel> {
        let url_ = this.baseUrl + "/api/AppMenus/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppMenuModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppMenuModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppMenuModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppMenuModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAppMenuCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/AppMenus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateAppMenuCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/AppMenus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/AppMenus/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllMenuAsTree(): Observable<TreeNodeModel[]> {
        let url_ = this.baseUrl + "/api/AppMenus/GetAllMenuAsTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMenuAsTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMenuAsTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodeModel[]>;
        }));
    }

    protected processGetAllMenuAsTree(response: HttpResponseBase): Observable<TreeNodeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reorderAppMenus(command: UpdateAppMenuOrderCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/AppMenus/ReorderAppMenus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorderAppMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorderAppMenus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorderAppMenus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAppNotificationsClient {
    getAll(query: GetAppNotificationListQuery): Observable<PaginatedResponseOfAppNotificationModel>;
    getByUser(): Observable<AppNotificationModel[]>;
}

@Injectable()
export class AppNotificationsClient implements IAppNotificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetAppNotificationListQuery): Observable<PaginatedResponseOfAppNotificationModel> {
        let url_ = this.baseUrl + "/api/AppNotifications/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfAppNotificationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfAppNotificationModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfAppNotificationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfAppNotificationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByUser(): Observable<AppNotificationModel[]> {
        let url_ = this.baseUrl + "/api/AppNotifications/GetByUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppNotificationModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppNotificationModel[]>;
        }));
    }

    protected processGetByUser(response: HttpResponseBase): Observable<AppNotificationModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppNotificationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAppPagesClient {
    getAll(query: GetAppPageListQuery): Observable<PaginatedResponseOfAppPageModel>;
    get(id: string): Observable<AppPageModel>;
    create(command: CreateAppPageCommand): Observable<string>;
    update(command: UpdateAppPageCommand): Observable<void>;
    upsertAppPage(command: UpsertAppPageCommand): Observable<string>;
    delete(id: string): Observable<void>;
}

@Injectable()
export class AppPagesClient implements IAppPagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetAppPageListQuery): Observable<PaginatedResponseOfAppPageModel> {
        let url_ = this.baseUrl + "/api/AppPages/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfAppPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfAppPageModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfAppPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfAppPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<AppPageModel> {
        let url_ = this.baseUrl + "/api/AppPages/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppPageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppPageModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppPageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAppPageCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/AppPages/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateAppPageCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/AppPages/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upsertAppPage(command: UpsertAppPageCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/AppPages/UpsertAppPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertAppPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertAppPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpsertAppPage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/AppPages/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IManageFilesClient {
    upload(): Observable<FileResponse[]>;
    removeFile(removeFileReq: RemoveFileRequest): Observable<FileResponse>;
}

@Injectable()
export class ManageFilesClient implements IManageFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    upload(): Observable<FileResponse[]> {
        let url_ = this.baseUrl + "/api/ManageFiles/Upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse[]>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<FileResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeFile(removeFileReq: RemoveFileRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ManageFiles/RemoveFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeFileReq);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRolesClient {
    getAll(query: GetRoleListQuery): Observable<PaginatedResponseOfRoleModel>;
    get(id: string): Observable<RoleModel>;
    create(command: CreateRoleCommand): Observable<string>;
    update(command: UpdateRoleCommand): Observable<void>;
    getRolePermissions(id: string): Observable<DynamicTreeNodeModel[]>;
}

@Injectable()
export class RolesClient implements IRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetRoleListQuery): Observable<PaginatedResponseOfRoleModel> {
        let url_ = this.baseUrl + "/api/Roles/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfRoleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfRoleModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfRoleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfRoleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<RoleModel> {
        let url_ = this.baseUrl + "/api/Roles/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateRoleCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Roles/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateRoleCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Roles/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRolePermissions(id: string): Observable<DynamicTreeNodeModel[]> {
        let url_ = this.baseUrl + "/api/Roles/GetRolePermissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicTreeNodeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicTreeNodeModel[]>;
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<DynamicTreeNodeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicTreeNodeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUsersClient {
    getAll(query: GetAppUserListQuery): Observable<PaginatedResponseOfAppUserModel>;
    get(id: string): Observable<AppUserModel>;
    getProfile(): Observable<AppUserModel>;
    create(command: CreateAppUserCommand): Observable<string>;
    update(command: UpdateAppUserCommand): Observable<void>;
    changePhoto(command: ChangeUserPhotoCommand): Observable<void>;
    updateBasic(command: UpdateAppUserBasicCommand): Observable<void>;
    addToRoles(command: AddToRolesCommand): Observable<void>;
}

@Injectable()
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetAppUserListQuery): Observable<PaginatedResponseOfAppUserModel> {
        let url_ = this.baseUrl + "/api/Users/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfAppUserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfAppUserModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfAppUserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfAppUserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<AppUserModel> {
        let url_ = this.baseUrl + "/api/Users/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppUserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppUserModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppUserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppUserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProfile(): Observable<AppUserModel> {
        let url_ = this.baseUrl + "/api/Users/GetProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppUserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppUserModel>;
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<AppUserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppUserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAppUserCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Users/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateAppUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePhoto(command: ChangeUserPhotoCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/ChangePhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBasic(command: UpdateAppUserBasicCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/UpdateBasic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBasic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBasic(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addToRoles(command: AddToRolesCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/AddToRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddToRoles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IExpensesClient {
    getAll(query: GetExpenseListQuery): Observable<PaginatedResponseOfExpenseModel>;
    get(id: string): Observable<ExpenseModel>;
    create(command: CreateExpenseCommand): Observable<string>;
    update(command: UpdateExpenseCommand): Observable<void>;
    delete(id: string): Observable<void>;
    deleteMultiple(ids: string[]): Observable<void>;
}

@Injectable()
export class ExpensesClient implements IExpensesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query: GetExpenseListQuery): Observable<PaginatedResponseOfExpenseModel> {
        let url_ = this.baseUrl + "/api/Expenses/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedResponseOfExpenseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedResponseOfExpenseModel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaginatedResponseOfExpenseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResponseOfExpenseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<ExpenseModel> {
        let url_ = this.baseUrl + "/api/Expenses/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ExpenseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateExpenseCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Expenses/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateExpenseCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Expenses/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Expenses/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMultiple(ids: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Expenses/DeleteMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class PaginatedResponseOfAccountModel implements IPaginatedResponseOfAccountModel {
    items?: AccountModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccountModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfAccountModel {
    items?: AccountModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class AccountModel implements IAccountModel {
    id?: string;
    accountNo?: number;
    name?: string;
    balance?: number;
    note?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountNo = _data["accountNo"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.note = _data["note"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): AccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNo"] = this.accountNo;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["note"] = this.note;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IAccountModel {
    id?: string;
    accountNo?: number;
    name?: string;
    balance?: number;
    note?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export abstract class DataGridModel implements IDataGridModel {
    isInitialLoaded?: boolean;
    allowCache?: boolean | undefined;
    pageNumber?: number;
    pageSize?: number;
    offset?: number;
    sortField?: string;
    sortOrder?: number | undefined;
    defaultOrderFieldName?: string | undefined;
    globalFilterValue?: string;
    globalFilterFields?: GlobalFilterFieldModel[];
    filters?: DataFilterModel[];

    constructor(data?: IDataGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isInitialLoaded = _data["isInitialLoaded"];
            this.allowCache = _data["allowCache"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.offset = _data["offset"];
            this.sortField = _data["sortField"];
            this.sortOrder = _data["sortOrder"];
            this.defaultOrderFieldName = _data["defaultOrderFieldName"];
            this.globalFilterValue = _data["globalFilterValue"];
            if (Array.isArray(_data["globalFilterFields"])) {
                this.globalFilterFields = [] as any;
                for (let item of _data["globalFilterFields"])
                    this.globalFilterFields!.push(GlobalFilterFieldModel.fromJS(item));
            }
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(DataFilterModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGridModel {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DataGridModel' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isInitialLoaded"] = this.isInitialLoaded;
        data["allowCache"] = this.allowCache;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["offset"] = this.offset;
        data["sortField"] = this.sortField;
        data["sortOrder"] = this.sortOrder;
        data["defaultOrderFieldName"] = this.defaultOrderFieldName;
        data["globalFilterValue"] = this.globalFilterValue;
        if (Array.isArray(this.globalFilterFields)) {
            data["globalFilterFields"] = [];
            for (let item of this.globalFilterFields)
                data["globalFilterFields"].push(item.toJSON());
        }
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDataGridModel {
    isInitialLoaded?: boolean;
    allowCache?: boolean | undefined;
    pageNumber?: number;
    pageSize?: number;
    offset?: number;
    sortField?: string;
    sortOrder?: number | undefined;
    defaultOrderFieldName?: string | undefined;
    globalFilterValue?: string;
    globalFilterFields?: GlobalFilterFieldModel[];
    filters?: DataFilterModel[];
}

export class GetAccountsListQuery extends DataGridModel implements IGetAccountsListQuery {
    cacheKey?: string;

    constructor(data?: IGetAccountsListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetAccountsListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountsListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetAccountsListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class GlobalFilterFieldModel implements IGlobalFilterFieldModel {
    field?: string;
    dbField?: string;
    fieldType?: string;
    matchMode?: string;

    constructor(data?: IGlobalFilterFieldModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.dbField = _data["dbField"];
            this.fieldType = _data["fieldType"];
            this.matchMode = _data["matchMode"];
        }
    }

    static fromJS(data: any): GlobalFilterFieldModel {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalFilterFieldModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["dbField"] = this.dbField;
        data["fieldType"] = this.fieldType;
        data["matchMode"] = this.matchMode;
        return data;
    }
}

export interface IGlobalFilterFieldModel {
    field?: string;
    dbField?: string;
    fieldType?: string;
    matchMode?: string;
}

export class DataFilterModel implements IDataFilterModel {
    field?: string;
    fieldType?: string;
    value?: string;
    filterType?: string;
    matchMode?: string;
    operator?: string;
    dsName?: string;
    dbField?: string;

    constructor(data?: IDataFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.fieldType = _data["fieldType"];
            this.value = _data["value"];
            this.filterType = _data["filterType"];
            this.matchMode = _data["matchMode"];
            this.operator = _data["operator"];
            this.dsName = _data["dsName"];
            this.dbField = _data["dbField"];
        }
    }

    static fromJS(data: any): DataFilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new DataFilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["fieldType"] = this.fieldType;
        data["value"] = this.value;
        data["filterType"] = this.filterType;
        data["matchMode"] = this.matchMode;
        data["operator"] = this.operator;
        data["dsName"] = this.dsName;
        data["dbField"] = this.dbField;
        return data;
    }
}

export interface IDataFilterModel {
    field?: string;
    fieldType?: string;
    value?: string;
    filterType?: string;
    matchMode?: string;
    operator?: string;
    dsName?: string;
    dbField?: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class CreateAccountCommand implements ICreateAccountCommand {
    accountNo?: number;
    name!: string;
    balance?: number;
    note?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountNo = _data["accountNo"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.note = _data["note"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNo"] = this.accountNo;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["note"] = this.note;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateAccountCommand {
    accountNo?: number;
    name: string;
    balance?: number;
    note?: string | undefined;
    cacheKey?: string;
}

export class UpdateAccountCommand implements IUpdateAccountCommand {
    id!: string;
    accountNo?: number;
    name!: string;
    balance?: number;
    note?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountNo = _data["accountNo"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.note = _data["note"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNo"] = this.accountNo;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["note"] = this.note;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateAccountCommand {
    id: string;
    accountNo?: number;
    name: string;
    balance?: number;
    note?: string | undefined;
    cacheKey?: string;
}

export class AuthenticatedResponse implements IAuthenticatedResponse {
    accessToken?: string;
    tokenType?: string;
    expiresInMinutes?: number;
    refreshToken?: string;
    refreshTokenExpiresOn?: Date;

    constructor(data?: IAuthenticatedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.tokenType = _data["tokenType"];
            this.expiresInMinutes = _data["expiresInMinutes"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpiresOn = _data["refreshTokenExpiresOn"] ? new Date(_data["refreshTokenExpiresOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticatedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["tokenType"] = this.tokenType;
        data["expiresInMinutes"] = this.expiresInMinutes;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpiresOn"] = this.refreshTokenExpiresOn ? this.refreshTokenExpiresOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuthenticatedResponse {
    accessToken?: string;
    tokenType?: string;
    expiresInMinutes?: number;
    refreshToken?: string;
    refreshTokenExpiresOn?: Date;
}

export class LoginRequestCommand implements ILoginRequestCommand {
    userName?: string;
    password?: string;
    isRemember?: boolean;

    constructor(data?: ILoginRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.isRemember = _data["isRemember"];
        }
    }

    static fromJS(data: any): LoginRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["isRemember"] = this.isRemember;
        return data;
    }
}

export interface ILoginRequestCommand {
    userName?: string;
    password?: string;
    isRemember?: boolean;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
    currentPassword?: string;
    newPassword?: string;

    constructor(data?: IChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordCommand {
    currentPassword?: string;
    newPassword?: string;
}

export class PaginatedResponseOfMoneyTransferModel implements IPaginatedResponseOfMoneyTransferModel {
    items?: MoneyTransferModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfMoneyTransferModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MoneyTransferModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfMoneyTransferModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfMoneyTransferModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfMoneyTransferModel {
    items?: MoneyTransferModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class MoneyTransferModel implements IMoneyTransferModel {
    id?: string;
    fromAccountId?: string;
    toAccountId?: string;
    amount?: number;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IMoneyTransferModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromAccountId = _data["fromAccountId"];
            this.toAccountId = _data["toAccountId"];
            this.amount = _data["amount"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): MoneyTransferModel {
        data = typeof data === 'object' ? data : {};
        let result = new MoneyTransferModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromAccountId"] = this.fromAccountId;
        data["toAccountId"] = this.toAccountId;
        data["amount"] = this.amount;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IMoneyTransferModel {
    id?: string;
    fromAccountId?: string;
    toAccountId?: string;
    amount?: number;
    optionsDataSources?: { [key: string]: any; };
}

export class GetMoneyTransfersListQuery extends DataGridModel implements IGetMoneyTransfersListQuery {
    cacheKey?: string;

    constructor(data?: IGetMoneyTransfersListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetMoneyTransfersListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetMoneyTransfersListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetMoneyTransfersListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateMoneyTransferCommand implements ICreateMoneyTransferCommand {
    fromAccountId?: string;
    toAccountId?: string;
    amount?: number;
    cacheKey?: string;

    constructor(data?: ICreateMoneyTransferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromAccountId = _data["fromAccountId"];
            this.toAccountId = _data["toAccountId"];
            this.amount = _data["amount"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateMoneyTransferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMoneyTransferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromAccountId"] = this.fromAccountId;
        data["toAccountId"] = this.toAccountId;
        data["amount"] = this.amount;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateMoneyTransferCommand {
    fromAccountId?: string;
    toAccountId?: string;
    amount?: number;
    cacheKey?: string;
}

export class UpdateMoneyTransferCommand implements IUpdateMoneyTransferCommand {
    id!: string;
    fromAccountId?: string;
    toAccountId?: string;
    amount?: number;
    cacheKey?: string;

    constructor(data?: IUpdateMoneyTransferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromAccountId = _data["fromAccountId"];
            this.toAccountId = _data["toAccountId"];
            this.amount = _data["amount"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateMoneyTransferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMoneyTransferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromAccountId"] = this.fromAccountId;
        data["toAccountId"] = this.toAccountId;
        data["amount"] = this.amount;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateMoneyTransferCommand {
    id: string;
    fromAccountId?: string;
    toAccountId?: string;
    amount?: number;
    cacheKey?: string;
}

export class SelectListModel implements ISelectListModel {
    id?: any;
    name?: string;
    isDefault?: boolean;
    severity?: string;

    constructor(data?: ISelectListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.severity = _data["severity"];
        }
    }

    static fromJS(data: any): SelectListModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["severity"] = this.severity;
        return data;
    }
}

export interface ISelectListModel {
    id?: any;
    name?: string;
    isDefault?: boolean;
    severity?: string;
}

export class PaginatedResponseOfCustomerGroupModel implements IPaginatedResponseOfCustomerGroupModel {
    items?: CustomerGroupModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfCustomerGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerGroupModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfCustomerGroupModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfCustomerGroupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfCustomerGroupModel {
    items?: CustomerGroupModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class CustomerGroupModel implements ICustomerGroupModel {
    id?: string;
    name?: string;
    rate?: number;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICustomerGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CustomerGroupModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerGroupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICustomerGroupModel {
    id?: string;
    name?: string;
    rate?: number;
    optionsDataSources?: { [key: string]: any; };
}

export class GetCustomerGroupListQuery extends DataGridModel implements IGetCustomerGroupListQuery {
    cacheKey?: string;

    constructor(data?: IGetCustomerGroupListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetCustomerGroupListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerGroupListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetCustomerGroupListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateCustomerGroupCommand implements ICreateCustomerGroupCommand {
    name!: string;
    rate?: number;
    cacheKey?: string;

    constructor(data?: ICreateCustomerGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCustomerGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCustomerGroupCommand {
    name: string;
    rate?: number;
    cacheKey?: string;
}

export class UpdateCustomerGroupCommand implements IUpdateCustomerGroupCommand {
    id?: string;
    name!: string;
    rate?: number;
    cacheKey?: string;

    constructor(data?: IUpdateCustomerGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCustomerGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCustomerGroupCommand {
    id?: string;
    name: string;
    rate?: number;
    cacheKey?: string;
}

export class PaginatedResponseOfCustomerModel implements IPaginatedResponseOfCustomerModel {
    items?: CustomerModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfCustomerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfCustomerModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfCustomerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfCustomerModel {
    items?: CustomerModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class CustomerModel implements ICustomerModel {
    id?: string;
    name?: string;
    identityNo?: string;
    email?: string | undefined;
    phoneNo?: string;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    totalDueAmount?: number;
    totalSaleReturnAmount?: number;
    totalPaidAmount?: number;
    rewardPoints?: number | undefined;
    isActive?: boolean;
    active?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICustomerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.identityNo = _data["identityNo"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.totalDueAmount = _data["totalDueAmount"];
            this.totalSaleReturnAmount = _data["totalSaleReturnAmount"];
            this.totalPaidAmount = _data["totalPaidAmount"];
            this.rewardPoints = _data["rewardPoints"];
            this.isActive = _data["isActive"];
            this.active = _data["active"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CustomerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["identityNo"] = this.identityNo;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["totalDueAmount"] = this.totalDueAmount;
        data["totalSaleReturnAmount"] = this.totalSaleReturnAmount;
        data["totalPaidAmount"] = this.totalPaidAmount;
        data["rewardPoints"] = this.rewardPoints;
        data["isActive"] = this.isActive;
        data["active"] = this.active;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICustomerModel {
    id?: string;
    name?: string;
    identityNo?: string;
    email?: string | undefined;
    phoneNo?: string;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    totalDueAmount?: number;
    totalSaleReturnAmount?: number;
    totalPaidAmount?: number;
    rewardPoints?: number | undefined;
    isActive?: boolean;
    active?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetCustomerListQuery extends DataGridModel implements IGetCustomerListQuery {
    cacheKey?: string;

    constructor(data?: IGetCustomerListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetCustomerListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetCustomerListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    name!: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCustomerCommand {
    name: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    id?: string;
    name!: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCustomerCommand {
    id?: string;
    name: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;
}

export class PaginatedResponseOfSupplierModel implements IPaginatedResponseOfSupplierModel {
    items?: SupplierModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfSupplierModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfSupplierModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfSupplierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfSupplierModel {
    items?: SupplierModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class SupplierModel implements ISupplierModel {
    id?: string;
    name?: string;
    email?: string | undefined;
    phoneNo?: string;
    mobile?: string | undefined;
    country?: string;
    city?: string | undefined;
    address?: string | undefined;
    openingBalance?: number;
    totalDueAmount?: number;
    totalPaidAmount?: number;
    outstandingBalance?: number;
    previousBalance?: number;
    isActive?: boolean;
    active?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ISupplierModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.openingBalance = _data["openingBalance"];
            this.totalDueAmount = _data["totalDueAmount"];
            this.totalPaidAmount = _data["totalPaidAmount"];
            this.outstandingBalance = _data["outstandingBalance"];
            this.previousBalance = _data["previousBalance"];
            this.isActive = _data["isActive"];
            this.active = _data["active"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): SupplierModel {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["openingBalance"] = this.openingBalance;
        data["totalDueAmount"] = this.totalDueAmount;
        data["totalPaidAmount"] = this.totalPaidAmount;
        data["outstandingBalance"] = this.outstandingBalance;
        data["previousBalance"] = this.previousBalance;
        data["isActive"] = this.isActive;
        data["active"] = this.active;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ISupplierModel {
    id?: string;
    name?: string;
    email?: string | undefined;
    phoneNo?: string;
    mobile?: string | undefined;
    country?: string;
    city?: string | undefined;
    address?: string | undefined;
    openingBalance?: number;
    totalDueAmount?: number;
    totalPaidAmount?: number;
    outstandingBalance?: number;
    previousBalance?: number;
    isActive?: boolean;
    active?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetSupplierListQuery extends DataGridModel implements IGetSupplierListQuery {
    cacheKey?: string;

    constructor(data?: IGetSupplierListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetSupplierListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupplierListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetSupplierListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateSupplierCommand implements ICreateSupplierCommand {
    name!: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    openingBalance?: number;
    isActive?: boolean;
    cacheKey?: string;

    constructor(data?: ICreateSupplierCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.openingBalance = _data["openingBalance"];
            this.isActive = _data["isActive"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateSupplierCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["openingBalance"] = this.openingBalance;
        data["isActive"] = this.isActive;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateSupplierCommand {
    name: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    openingBalance?: number;
    isActive?: boolean;
    cacheKey?: string;
}

export class UpdateSupplierCommand implements IUpdateSupplierCommand {
    id?: string;
    name!: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;

    constructor(data?: IUpdateSupplierCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateSupplierCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSupplierCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateSupplierCommand {
    id?: string;
    name: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;
}

export class DynamicTreeNodeModel implements IDynamicTreeNodeModel {
    key?: any;
    label?: string;
    icon?: string;
    parentId?: any | undefined;
    data?: string;
    disabledCheckbox?: boolean;
    disabled?: boolean;
    visible?: boolean;
    isActive?: boolean;
    partialSelected?: boolean;
    orderNo?: number;
    leaf?: boolean;
    parent?: DynamicTreeNodeModel | undefined;
    children?: DynamicTreeNodeModel[];

    constructor(data?: IDynamicTreeNodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.icon = _data["icon"];
            this.parentId = _data["parentId"];
            this.data = _data["data"];
            this.disabledCheckbox = _data["disabledCheckbox"];
            this.disabled = _data["disabled"];
            this.visible = _data["visible"];
            this.isActive = _data["isActive"];
            this.partialSelected = _data["partialSelected"];
            this.orderNo = _data["orderNo"];
            this.leaf = _data["leaf"];
            this.parent = _data["parent"] ? DynamicTreeNodeModel.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(DynamicTreeNodeModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicTreeNodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicTreeNodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["icon"] = this.icon;
        data["parentId"] = this.parentId;
        data["data"] = this.data;
        data["disabledCheckbox"] = this.disabledCheckbox;
        data["disabled"] = this.disabled;
        data["visible"] = this.visible;
        data["isActive"] = this.isActive;
        data["partialSelected"] = this.partialSelected;
        data["orderNo"] = this.orderNo;
        data["leaf"] = this.leaf;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicTreeNodeModel {
    key?: any;
    label?: string;
    icon?: string;
    parentId?: any | undefined;
    data?: string;
    disabledCheckbox?: boolean;
    disabled?: boolean;
    visible?: boolean;
    isActive?: boolean;
    partialSelected?: boolean;
    orderNo?: number;
    leaf?: boolean;
    parent?: DynamicTreeNodeModel | undefined;
    children?: DynamicTreeNodeModel[];
}

export class TreeNodeModel implements ITreeNodeModel {
    key?: string;
    label?: string;
    icon?: string;
    parentId?: string | undefined;
    data?: string;
    disabledCheckbox?: boolean;
    disabled?: boolean;
    visible?: boolean;
    isActive?: boolean;
    partialSelected?: boolean;
    orderNo?: number;
    leaf?: boolean;
    parent?: TreeNodeModel | undefined;
    children?: TreeNodeModel[];

    constructor(data?: ITreeNodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.icon = _data["icon"];
            this.parentId = _data["parentId"];
            this.data = _data["data"];
            this.disabledCheckbox = _data["disabledCheckbox"];
            this.disabled = _data["disabled"];
            this.visible = _data["visible"];
            this.isActive = _data["isActive"];
            this.partialSelected = _data["partialSelected"];
            this.orderNo = _data["orderNo"];
            this.leaf = _data["leaf"];
            this.parent = _data["parent"] ? TreeNodeModel.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeNodeModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeNodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["icon"] = this.icon;
        data["parentId"] = this.parentId;
        data["data"] = this.data;
        data["disabledCheckbox"] = this.disabledCheckbox;
        data["disabled"] = this.disabled;
        data["visible"] = this.visible;
        data["isActive"] = this.isActive;
        data["partialSelected"] = this.partialSelected;
        data["orderNo"] = this.orderNo;
        data["leaf"] = this.leaf;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITreeNodeModel {
    key?: string;
    label?: string;
    icon?: string;
    parentId?: string | undefined;
    data?: string;
    disabledCheckbox?: boolean;
    disabled?: boolean;
    visible?: boolean;
    isActive?: boolean;
    partialSelected?: boolean;
    orderNo?: number;
    leaf?: boolean;
    parent?: TreeNodeModel | undefined;
    children?: TreeNodeModel[];
}

export class CompanyInfoModel implements ICompanyInfoModel {
    id?: string;
    name?: string;
    phone?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    address?: string | undefined;
    logoUrl?: string | undefined;
    signatureUrl?: string | undefined;
    website?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICompanyInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.address = _data["address"];
            this.logoUrl = _data["logoUrl"];
            this.signatureUrl = _data["signatureUrl"];
            this.website = _data["website"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CompanyInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["address"] = this.address;
        data["logoUrl"] = this.logoUrl;
        data["signatureUrl"] = this.signatureUrl;
        data["website"] = this.website;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICompanyInfoModel {
    id?: string;
    name?: string;
    phone?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    address?: string | undefined;
    logoUrl?: string | undefined;
    signatureUrl?: string | undefined;
    website?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class CreateCompanyInfoCommand implements ICreateCompanyInfoCommand {
    name?: string;
    phone?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    address?: string | undefined;
    logoUrl?: string | undefined;
    signatureUrl?: string | undefined;
    website?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateCompanyInfoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.address = _data["address"];
            this.logoUrl = _data["logoUrl"];
            this.signatureUrl = _data["signatureUrl"];
            this.website = _data["website"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCompanyInfoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyInfoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["address"] = this.address;
        data["logoUrl"] = this.logoUrl;
        data["signatureUrl"] = this.signatureUrl;
        data["website"] = this.website;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCompanyInfoCommand {
    name?: string;
    phone?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    address?: string | undefined;
    logoUrl?: string | undefined;
    signatureUrl?: string | undefined;
    website?: string | undefined;
    cacheKey?: string;
}

export class UpdateCompanyInfoCommand implements IUpdateCompanyInfoCommand {
    id!: string;
    name?: string;
    phone?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    address?: string | undefined;
    logoUrl?: string | undefined;
    signatureUrl?: string | undefined;
    website?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateCompanyInfoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.address = _data["address"];
            this.logoUrl = _data["logoUrl"];
            this.signatureUrl = _data["signatureUrl"];
            this.website = _data["website"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCompanyInfoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyInfoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["address"] = this.address;
        data["logoUrl"] = this.logoUrl;
        data["signatureUrl"] = this.signatureUrl;
        data["website"] = this.website;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCompanyInfoCommand {
    id: string;
    name?: string;
    phone?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    address?: string | undefined;
    logoUrl?: string | undefined;
    signatureUrl?: string | undefined;
    website?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfSaleReturnModel implements IPaginatedResponseOfSaleReturnModel {
    items?: SaleReturnModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfSaleReturnModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SaleReturnModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfSaleReturnModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfSaleReturnModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfSaleReturnModel {
    items?: SaleReturnModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class SaleReturnModel implements ISaleReturnModel {
    id?: string;
    returnDate?: Date;
    soldReferenceNo?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    returnStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    returnNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    returnStatus?: string;
    paymentStatus?: string;
    saleReturnDetails?: SaleReturnDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ISaleReturnModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnDate = _data["returnDate"] ? new Date(_data["returnDate"].toString()) : <any>undefined;
            this.soldReferenceNo = _data["soldReferenceNo"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.returnStatusId = _data["returnStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.discountType = _data["discountType"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.returnNote = _data["returnNote"];
            this.staffNote = _data["staffNote"];
            this.warehouseName = _data["warehouseName"];
            this.customerName = _data["customerName"];
            this.returnStatus = _data["returnStatus"];
            this.paymentStatus = _data["paymentStatus"];
            if (Array.isArray(_data["saleReturnDetails"])) {
                this.saleReturnDetails = [] as any;
                for (let item of _data["saleReturnDetails"])
                    this.saleReturnDetails!.push(SaleReturnDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): SaleReturnModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleReturnModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnDate"] = this.returnDate ? formatDate(this.returnDate) : <any>undefined;
        data["soldReferenceNo"] = this.soldReferenceNo;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["returnStatusId"] = this.returnStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["discountType"] = this.discountType;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["returnNote"] = this.returnNote;
        data["staffNote"] = this.staffNote;
        data["warehouseName"] = this.warehouseName;
        data["customerName"] = this.customerName;
        data["returnStatus"] = this.returnStatus;
        data["paymentStatus"] = this.paymentStatus;
        if (Array.isArray(this.saleReturnDetails)) {
            data["saleReturnDetails"] = [];
            for (let item of this.saleReturnDetails)
                data["saleReturnDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ISaleReturnModel {
    id?: string;
    returnDate?: Date;
    soldReferenceNo?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    returnStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    returnNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    returnStatus?: string;
    paymentStatus?: string;
    saleReturnDetails?: SaleReturnDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export enum DiscountType {
    Fixed = 1,
    Percentage = 2,
}

export class SaleReturnDetailModel implements ISaleReturnDetailModel {
    id?: string;
    saleReturnId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    soldQuantity?: number;
    returnedQuantity?: number;
    stock?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitPrice?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;

    constructor(data?: ISaleReturnDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleReturnId = _data["saleReturnId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productUnitCost = _data["productUnitCost"];
            this.productUnitPrice = _data["productUnitPrice"];
            this.productUnitId = _data["productUnitId"];
            this.productUnit = _data["productUnit"];
            this.productUnitDiscount = _data["productUnitDiscount"];
            this.soldQuantity = _data["soldQuantity"];
            this.returnedQuantity = _data["returnedQuantity"];
            this.stock = _data["stock"];
            this.batchNo = _data["batchNo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.netUnitPrice = _data["netUnitPrice"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.totalPrice = _data["totalPrice"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): SaleReturnDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleReturnDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleReturnId"] = this.saleReturnId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productUnitCost"] = this.productUnitCost;
        data["productUnitPrice"] = this.productUnitPrice;
        data["productUnitId"] = this.productUnitId;
        data["productUnit"] = this.productUnit;
        data["productUnitDiscount"] = this.productUnitDiscount;
        data["soldQuantity"] = this.soldQuantity;
        data["returnedQuantity"] = this.returnedQuantity;
        data["stock"] = this.stock;
        data["batchNo"] = this.batchNo;
        data["expiredDate"] = this.expiredDate ? formatDate(this.expiredDate) : <any>undefined;
        data["netUnitPrice"] = this.netUnitPrice;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["totalPrice"] = this.totalPrice;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface ISaleReturnDetailModel {
    id?: string;
    saleReturnId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    soldQuantity?: number;
    returnedQuantity?: number;
    stock?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitPrice?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;
}

export enum TaxMethod {
    Exclusive = 1,
    Inclusive = 2,
}

export class GetSaleReturnListQuery extends DataGridModel implements IGetSaleReturnListQuery {
    cacheKey?: string;

    constructor(data?: IGetSaleReturnListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetSaleReturnListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSaleReturnListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetSaleReturnListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class UpsertSaleReturnModel implements IUpsertSaleReturnModel {
    id?: string;
    saleId?: string;
    returnDate?: Date;
    soldReferenceNo?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    customer?: string | undefined;
    billerId?: string;
    attachmentUrl?: string | undefined;
    returnStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    returnNote?: string | undefined;
    staffNote?: string | undefined;
    saleReturnDetails?: SaleReturnDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IUpsertSaleReturnModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleId = _data["saleId"];
            this.returnDate = _data["returnDate"] ? new Date(_data["returnDate"].toString()) : <any>undefined;
            this.soldReferenceNo = _data["soldReferenceNo"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.returnStatusId = _data["returnStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.returnNote = _data["returnNote"];
            this.staffNote = _data["staffNote"];
            if (Array.isArray(_data["saleReturnDetails"])) {
                this.saleReturnDetails = [] as any;
                for (let item of _data["saleReturnDetails"])
                    this.saleReturnDetails!.push(SaleReturnDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpsertSaleReturnModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertSaleReturnModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleId"] = this.saleId;
        data["returnDate"] = this.returnDate ? formatDate(this.returnDate) : <any>undefined;
        data["soldReferenceNo"] = this.soldReferenceNo;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["returnStatusId"] = this.returnStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["returnNote"] = this.returnNote;
        data["staffNote"] = this.staffNote;
        if (Array.isArray(this.saleReturnDetails)) {
            data["saleReturnDetails"] = [];
            for (let item of this.saleReturnDetails)
                data["saleReturnDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IUpsertSaleReturnModel {
    id?: string;
    saleId?: string;
    returnDate?: Date;
    soldReferenceNo?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    customer?: string | undefined;
    billerId?: string;
    attachmentUrl?: string | undefined;
    returnStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    returnNote?: string | undefined;
    staffNote?: string | undefined;
    saleReturnDetails?: SaleReturnDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class SaleReturnInfoModel implements ISaleReturnInfoModel {
    id?: string;
    returnDate?: Date;
    soldReferenceNo?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    returnStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    subTotal?: number;
    grandTotal?: number;
    returnNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    returnStatus?: string;
    paymentStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    customer?: CustomerModel;
    saleReturnDetails?: SaleReturnDetailModel[];

    constructor(data?: ISaleReturnInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.returnDate = _data["returnDate"] ? new Date(_data["returnDate"].toString()) : <any>undefined;
            this.soldReferenceNo = _data["soldReferenceNo"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.returnStatusId = _data["returnStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.discountType = _data["discountType"];
            this.shippingCost = _data["shippingCost"];
            this.subTotal = _data["subTotal"];
            this.grandTotal = _data["grandTotal"];
            this.returnNote = _data["returnNote"];
            this.staffNote = _data["staffNote"];
            this.warehouseName = _data["warehouseName"];
            this.customerName = _data["customerName"];
            this.returnStatus = _data["returnStatus"];
            this.paymentStatus = _data["paymentStatus"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalDiscount = _data["totalDiscount"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.totalItems = _data["totalItems"];
            this.companyInfo = _data["companyInfo"] ? CompanyInfoModel.fromJS(_data["companyInfo"]) : <any>undefined;
            this.customer = _data["customer"] ? CustomerModel.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["saleReturnDetails"])) {
                this.saleReturnDetails = [] as any;
                for (let item of _data["saleReturnDetails"])
                    this.saleReturnDetails!.push(SaleReturnDetailModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleReturnInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleReturnInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["returnDate"] = this.returnDate ? formatDate(this.returnDate) : <any>undefined;
        data["soldReferenceNo"] = this.soldReferenceNo;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["returnStatusId"] = this.returnStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["discountType"] = this.discountType;
        data["shippingCost"] = this.shippingCost;
        data["subTotal"] = this.subTotal;
        data["grandTotal"] = this.grandTotal;
        data["returnNote"] = this.returnNote;
        data["staffNote"] = this.staffNote;
        data["warehouseName"] = this.warehouseName;
        data["customerName"] = this.customerName;
        data["returnStatus"] = this.returnStatus;
        data["paymentStatus"] = this.paymentStatus;
        data["totalQuantity"] = this.totalQuantity;
        data["totalDiscount"] = this.totalDiscount;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["totalItems"] = this.totalItems;
        data["companyInfo"] = this.companyInfo ? this.companyInfo.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.saleReturnDetails)) {
            data["saleReturnDetails"] = [];
            for (let item of this.saleReturnDetails)
                data["saleReturnDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaleReturnInfoModel {
    id?: string;
    returnDate?: Date;
    soldReferenceNo?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    returnStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    subTotal?: number;
    grandTotal?: number;
    returnNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    returnStatus?: string;
    paymentStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    customer?: CustomerModel;
    saleReturnDetails?: SaleReturnDetailModel[];
}

export class CreateSaleReturnCommand extends UpsertSaleReturnModel implements ICreateSaleReturnCommand {
    cacheKey?: string;

    constructor(data?: ICreateSaleReturnCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): CreateSaleReturnCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSaleReturnCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateSaleReturnCommand extends IUpsertSaleReturnModel {
    cacheKey?: string;
}

export class UpdateSaleReturnCommand extends UpsertSaleReturnModel implements IUpdateSaleReturnCommand {
    cacheKey?: string;

    constructor(data?: IUpdateSaleReturnCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): UpdateSaleReturnCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSaleReturnCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateSaleReturnCommand extends IUpsertSaleReturnModel {
    cacheKey?: string;
}

export class PaginatedResponseOfCouponModel implements IPaginatedResponseOfCouponModel {
    items?: CouponModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfCouponModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CouponModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfCouponModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfCouponModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfCouponModel {
    items?: CouponModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class CouponModel implements ICouponModel {
    id?: string;
    code?: string | undefined;
    name?: string;
    description?: string | undefined;
    discountType?: number;
    amount?: number;
    expiryDate?: Date;
    allowFreeShipping?: boolean;
    minimumSpend?: number | undefined;
    maximumSpend?: number | undefined;
    onlyIndivisual?: boolean;
    perCouponUsageLimit?: number | undefined;
    perUserUsageLimit?: number | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICouponModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.amount = _data["amount"];
            this.expiryDate = _data["expiryDate"] ? new Date(_data["expiryDate"].toString()) : <any>undefined;
            this.allowFreeShipping = _data["allowFreeShipping"];
            this.minimumSpend = _data["minimumSpend"];
            this.maximumSpend = _data["maximumSpend"];
            this.onlyIndivisual = _data["onlyIndivisual"];
            this.perCouponUsageLimit = _data["perCouponUsageLimit"];
            this.perUserUsageLimit = _data["perUserUsageLimit"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CouponModel {
        data = typeof data === 'object' ? data : {};
        let result = new CouponModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["amount"] = this.amount;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["allowFreeShipping"] = this.allowFreeShipping;
        data["minimumSpend"] = this.minimumSpend;
        data["maximumSpend"] = this.maximumSpend;
        data["onlyIndivisual"] = this.onlyIndivisual;
        data["perCouponUsageLimit"] = this.perCouponUsageLimit;
        data["perUserUsageLimit"] = this.perUserUsageLimit;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICouponModel {
    id?: string;
    code?: string | undefined;
    name?: string;
    description?: string | undefined;
    discountType?: number;
    amount?: number;
    expiryDate?: Date;
    allowFreeShipping?: boolean;
    minimumSpend?: number | undefined;
    maximumSpend?: number | undefined;
    onlyIndivisual?: boolean;
    perCouponUsageLimit?: number | undefined;
    perUserUsageLimit?: number | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetCouponListQuery extends DataGridModel implements IGetCouponListQuery {
    cacheKey?: string;

    constructor(data?: IGetCouponListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetCouponListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCouponListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetCouponListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateCouponCommand implements ICreateCouponCommand {
    code?: string | undefined;
    name?: string;
    description?: string | undefined;
    discountType?: number;
    amount?: number;
    expiryDate?: Date;
    allowFreeShipping?: boolean;
    minimumSpend?: number | undefined;
    maximumSpend?: number | undefined;
    onlyIndivisual?: boolean;
    perCouponUsageLimit?: number | undefined;
    perUserUsageLimit?: number | undefined;
    cacheKey?: string;

    constructor(data?: ICreateCouponCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.amount = _data["amount"];
            this.expiryDate = _data["expiryDate"] ? new Date(_data["expiryDate"].toString()) : <any>undefined;
            this.allowFreeShipping = _data["allowFreeShipping"];
            this.minimumSpend = _data["minimumSpend"];
            this.maximumSpend = _data["maximumSpend"];
            this.onlyIndivisual = _data["onlyIndivisual"];
            this.perCouponUsageLimit = _data["perCouponUsageLimit"];
            this.perUserUsageLimit = _data["perUserUsageLimit"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCouponCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["amount"] = this.amount;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["allowFreeShipping"] = this.allowFreeShipping;
        data["minimumSpend"] = this.minimumSpend;
        data["maximumSpend"] = this.maximumSpend;
        data["onlyIndivisual"] = this.onlyIndivisual;
        data["perCouponUsageLimit"] = this.perCouponUsageLimit;
        data["perUserUsageLimit"] = this.perUserUsageLimit;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCouponCommand {
    code?: string | undefined;
    name?: string;
    description?: string | undefined;
    discountType?: number;
    amount?: number;
    expiryDate?: Date;
    allowFreeShipping?: boolean;
    minimumSpend?: number | undefined;
    maximumSpend?: number | undefined;
    onlyIndivisual?: boolean;
    perCouponUsageLimit?: number | undefined;
    perUserUsageLimit?: number | undefined;
    cacheKey?: string;
}

export class UpdateCouponCommand implements IUpdateCouponCommand {
    id!: string;
    code?: string | undefined;
    name?: string;
    description?: string | undefined;
    discountType?: number;
    amount?: number;
    expiryDate?: Date;
    allowFreeShipping?: boolean;
    minimumSpend?: number | undefined;
    maximumSpend?: number | undefined;
    onlyIndivisual?: boolean;
    perCouponUsageLimit?: number | undefined;
    perUserUsageLimit?: number | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateCouponCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.amount = _data["amount"];
            this.expiryDate = _data["expiryDate"] ? new Date(_data["expiryDate"].toString()) : <any>undefined;
            this.allowFreeShipping = _data["allowFreeShipping"];
            this.minimumSpend = _data["minimumSpend"];
            this.maximumSpend = _data["maximumSpend"];
            this.onlyIndivisual = _data["onlyIndivisual"];
            this.perCouponUsageLimit = _data["perCouponUsageLimit"];
            this.perUserUsageLimit = _data["perUserUsageLimit"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCouponCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCouponCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["amount"] = this.amount;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["allowFreeShipping"] = this.allowFreeShipping;
        data["minimumSpend"] = this.minimumSpend;
        data["maximumSpend"] = this.maximumSpend;
        data["onlyIndivisual"] = this.onlyIndivisual;
        data["perCouponUsageLimit"] = this.perCouponUsageLimit;
        data["perUserUsageLimit"] = this.perUserUsageLimit;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCouponCommand {
    id: string;
    code?: string | undefined;
    name?: string;
    description?: string | undefined;
    discountType?: number;
    amount?: number;
    expiryDate?: Date;
    allowFreeShipping?: boolean;
    minimumSpend?: number | undefined;
    maximumSpend?: number | undefined;
    onlyIndivisual?: boolean;
    perCouponUsageLimit?: number | undefined;
    perUserUsageLimit?: number | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfCourierModel implements IPaginatedResponseOfCourierModel {
    items?: CourierModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfCourierModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourierModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfCourierModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfCourierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfCourierModel {
    items?: CourierModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class CourierModel implements ICourierModel {
    id?: string;
    name?: string;
    phoneNo?: string | undefined;
    mobileNo?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICourierModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.mobileNo = _data["mobileNo"];
            this.email = _data["email"];
            this.address = _data["address"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CourierModel {
        data = typeof data === 'object' ? data : {};
        let result = new CourierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo"] = this.mobileNo;
        data["email"] = this.email;
        data["address"] = this.address;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICourierModel {
    id?: string;
    name?: string;
    phoneNo?: string | undefined;
    mobileNo?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetCourierListQuery extends DataGridModel implements IGetCourierListQuery {
    cacheKey?: string;

    constructor(data?: IGetCourierListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetCourierListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCourierListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetCourierListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateCourierCommand implements ICreateCourierCommand {
    name?: string;
    phoneNo?: string | undefined;
    mobileNo?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateCourierCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.mobileNo = _data["mobileNo"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCourierCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourierCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo"] = this.mobileNo;
        data["email"] = this.email;
        data["address"] = this.address;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCourierCommand {
    name?: string;
    phoneNo?: string | undefined;
    mobileNo?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    cacheKey?: string;
}

export class UpdateCourierCommand implements IUpdateCourierCommand {
    id!: string;
    name?: string;
    phoneNo?: string | undefined;
    mobileNo?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateCourierCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.mobileNo = _data["mobileNo"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCourierCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCourierCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo"] = this.mobileNo;
        data["email"] = this.email;
        data["address"] = this.address;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCourierCommand {
    id: string;
    name?: string;
    phoneNo?: string | undefined;
    mobileNo?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfGiftCardModel implements IPaginatedResponseOfGiftCardModel {
    items?: GiftCardModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfGiftCardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GiftCardModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfGiftCardModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfGiftCardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfGiftCardModel {
    items?: GiftCardModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class GiftCardModel implements IGiftCardModel {
    id?: string;
    cardNo?: string | undefined;
    amount?: number;
    expense?: number;
    balance?: number;
    expiredDate?: Date;
    customerId?: string | undefined;
    customer?: string;
    allowMultipleTransac?: boolean;
    status?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IGiftCardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cardNo = _data["cardNo"];
            this.amount = _data["amount"];
            this.expense = _data["expense"];
            this.balance = _data["balance"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customer = _data["customer"];
            this.allowMultipleTransac = _data["allowMultipleTransac"];
            this.status = _data["status"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): GiftCardModel {
        data = typeof data === 'object' ? data : {};
        let result = new GiftCardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cardNo"] = this.cardNo;
        data["amount"] = this.amount;
        data["expense"] = this.expense;
        data["balance"] = this.balance;
        data["expiredDate"] = this.expiredDate ? this.expiredDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer;
        data["allowMultipleTransac"] = this.allowMultipleTransac;
        data["status"] = this.status;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IGiftCardModel {
    id?: string;
    cardNo?: string | undefined;
    amount?: number;
    expense?: number;
    balance?: number;
    expiredDate?: Date;
    customerId?: string | undefined;
    customer?: string;
    allowMultipleTransac?: boolean;
    status?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetGiftCardListQuery extends DataGridModel implements IGetGiftCardListQuery {
    cacheKey?: string;

    constructor(data?: IGetGiftCardListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetGiftCardListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetGiftCardListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetGiftCardListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateGiftCardCommand implements ICreateGiftCardCommand {
    cardNo?: string | undefined;
    amount?: number | undefined;
    expiredDate?: Date | undefined;
    customerId?: string;
    allowMultipleTransac?: boolean;
    cacheKey?: string;

    constructor(data?: ICreateGiftCardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cardNo = _data["cardNo"];
            this.amount = _data["amount"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.allowMultipleTransac = _data["allowMultipleTransac"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateGiftCardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGiftCardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardNo"] = this.cardNo;
        data["amount"] = this.amount;
        data["expiredDate"] = this.expiredDate ? this.expiredDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["allowMultipleTransac"] = this.allowMultipleTransac;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateGiftCardCommand {
    cardNo?: string | undefined;
    amount?: number | undefined;
    expiredDate?: Date | undefined;
    customerId?: string;
    allowMultipleTransac?: boolean;
    cacheKey?: string;
}

export class UpdateGiftCardCommand implements IUpdateGiftCardCommand {
    id!: string;
    cardNo?: string | undefined;
    amount?: number | undefined;
    expiredDate?: Date | undefined;
    customerId?: string;
    allowMultipleTransac?: boolean;
    cacheKey?: string;

    constructor(data?: IUpdateGiftCardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cardNo = _data["cardNo"];
            this.amount = _data["amount"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.allowMultipleTransac = _data["allowMultipleTransac"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateGiftCardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGiftCardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cardNo"] = this.cardNo;
        data["amount"] = this.amount;
        data["expiredDate"] = this.expiredDate ? this.expiredDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["allowMultipleTransac"] = this.allowMultipleTransac;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateGiftCardCommand {
    id: string;
    cardNo?: string | undefined;
    amount?: number | undefined;
    expiredDate?: Date | undefined;
    customerId?: string;
    allowMultipleTransac?: boolean;
    cacheKey?: string;
}

export class PaginatedResponseOfSalePaymentModel implements IPaginatedResponseOfSalePaymentModel {
    items?: SalePaymentModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfSalePaymentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SalePaymentModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfSalePaymentModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfSalePaymentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfSalePaymentModel {
    items?: SalePaymentModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class SalePaymentModel implements ISalePaymentModel {
    id?: string;
    saleId?: string;
    paymentDate?: Date;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string | undefined;
    paymentTypeName?: string;
    createdBy?: string;
    note?: string | undefined;
    paymentDateString?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ISalePaymentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleId = _data["saleId"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.createdBy = _data["createdBy"];
            this.note = _data["note"];
            this.paymentDateString = _data["paymentDateString"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): SalePaymentModel {
        data = typeof data === 'object' ? data : {};
        let result = new SalePaymentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleId"] = this.saleId;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["paymentTypeName"] = this.paymentTypeName;
        data["createdBy"] = this.createdBy;
        data["note"] = this.note;
        data["paymentDateString"] = this.paymentDateString;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ISalePaymentModel {
    id?: string;
    saleId?: string;
    paymentDate?: Date;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string | undefined;
    paymentTypeName?: string;
    createdBy?: string;
    note?: string | undefined;
    paymentDateString?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetSalePaymentListQuery extends DataGridModel implements IGetSalePaymentListQuery {
    cacheKey?: string;
    saleId?: string;

    constructor(data?: IGetSalePaymentListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
            this.saleId = _data["saleId"];
        }
    }

    static override fromJS(data: any): GetSalePaymentListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalePaymentListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        data["saleId"] = this.saleId;
        super.toJSON(data);
        return data;
    }
}

export interface IGetSalePaymentListQuery extends IDataGridModel {
    cacheKey?: string;
    saleId?: string;
}

export class GetPaymentListBySaleIdQuery implements IGetPaymentListBySaleIdQuery {
    cacheKey?: string;
    saleId?: string;
    allowCache?: boolean | undefined;

    constructor(data?: IGetPaymentListBySaleIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cacheKey = _data["cacheKey"];
            this.saleId = _data["saleId"];
            this.allowCache = _data["allowCache"];
        }
    }

    static fromJS(data: any): GetPaymentListBySaleIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaymentListBySaleIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        data["saleId"] = this.saleId;
        data["allowCache"] = this.allowCache;
        return data;
    }
}

export interface IGetPaymentListBySaleIdQuery {
    cacheKey?: string;
    saleId?: string;
    allowCache?: boolean | undefined;
}

export class CreateSalePaymentCommand implements ICreateSalePaymentCommand {
    saleId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;

    constructor(data?: ICreateSalePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleId = _data["saleId"];
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): CreateSalePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleId"] = this.saleId;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["note"] = this.note;
        return data;
    }
}

export interface ICreateSalePaymentCommand {
    saleId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;
}

export class UpdateSalePaymentCommand implements IUpdateSalePaymentCommand {
    id!: string;
    saleId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateSalePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleId = _data["saleId"];
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.note = _data["note"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateSalePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSalePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleId"] = this.saleId;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["note"] = this.note;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateSalePaymentCommand {
    id: string;
    saleId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfSaleModel implements IPaginatedResponseOfSaleModel {
    items?: SaleModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfSaleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SaleModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfSaleModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfSaleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfSaleModel {
    items?: SaleModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class SaleModel implements ISaleModel {
    id?: string;
    saleDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    saleStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    saleNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    saleStatus?: string;
    paymentStatus?: string;
    saleDetails?: SaleDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ISaleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleDate = _data["saleDate"] ? new Date(_data["saleDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.saleStatusId = _data["saleStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.discountType = _data["discountType"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.saleNote = _data["saleNote"];
            this.staffNote = _data["staffNote"];
            this.warehouseName = _data["warehouseName"];
            this.customerName = _data["customerName"];
            this.saleStatus = _data["saleStatus"];
            this.paymentStatus = _data["paymentStatus"];
            if (Array.isArray(_data["saleDetails"])) {
                this.saleDetails = [] as any;
                for (let item of _data["saleDetails"])
                    this.saleDetails!.push(SaleDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): SaleModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleDate"] = this.saleDate ? formatDate(this.saleDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["saleStatusId"] = this.saleStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["discountType"] = this.discountType;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["saleNote"] = this.saleNote;
        data["staffNote"] = this.staffNote;
        data["warehouseName"] = this.warehouseName;
        data["customerName"] = this.customerName;
        data["saleStatus"] = this.saleStatus;
        data["paymentStatus"] = this.paymentStatus;
        if (Array.isArray(this.saleDetails)) {
            data["saleDetails"] = [];
            for (let item of this.saleDetails)
                data["saleDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ISaleModel {
    id?: string;
    saleDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    saleStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    saleNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    saleStatus?: string;
    paymentStatus?: string;
    saleDetails?: SaleDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class SaleDetailModel implements ISaleDetailModel {
    id?: string;
    saleId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitPrice?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;

    constructor(data?: ISaleDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleId = _data["saleId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productUnitCost = _data["productUnitCost"];
            this.productUnitPrice = _data["productUnitPrice"];
            this.productUnitId = _data["productUnitId"];
            this.productUnit = _data["productUnit"];
            this.productUnitDiscount = _data["productUnitDiscount"];
            this.quantity = _data["quantity"];
            this.batchNo = _data["batchNo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.netUnitPrice = _data["netUnitPrice"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.totalPrice = _data["totalPrice"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): SaleDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleId"] = this.saleId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productUnitCost"] = this.productUnitCost;
        data["productUnitPrice"] = this.productUnitPrice;
        data["productUnitId"] = this.productUnitId;
        data["productUnit"] = this.productUnit;
        data["productUnitDiscount"] = this.productUnitDiscount;
        data["quantity"] = this.quantity;
        data["batchNo"] = this.batchNo;
        data["expiredDate"] = this.expiredDate ? formatDate(this.expiredDate) : <any>undefined;
        data["netUnitPrice"] = this.netUnitPrice;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["totalPrice"] = this.totalPrice;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface ISaleDetailModel {
    id?: string;
    saleId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitPrice?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;
}

export class GetSaleListQuery extends DataGridModel implements IGetSaleListQuery {
    cacheKey?: string;

    constructor(data?: IGetSaleListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetSaleListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSaleListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetSaleListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class UpsertSaleModel implements IUpsertSaleModel {
    id?: string;
    saleDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    saleStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    saleNote?: string | undefined;
    staffNote?: string | undefined;
    salePayment?: AddSalePaymentModel;
    saleDetails?: SaleDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IUpsertSaleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleDate = _data["saleDate"] ? new Date(_data["saleDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.saleStatusId = _data["saleStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.saleNote = _data["saleNote"];
            this.staffNote = _data["staffNote"];
            this.salePayment = _data["salePayment"] ? AddSalePaymentModel.fromJS(_data["salePayment"]) : <any>undefined;
            if (Array.isArray(_data["saleDetails"])) {
                this.saleDetails = [] as any;
                for (let item of _data["saleDetails"])
                    this.saleDetails!.push(SaleDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpsertSaleModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertSaleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleDate"] = this.saleDate ? formatDate(this.saleDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["saleStatusId"] = this.saleStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["saleNote"] = this.saleNote;
        data["staffNote"] = this.staffNote;
        data["salePayment"] = this.salePayment ? this.salePayment.toJSON() : <any>undefined;
        if (Array.isArray(this.saleDetails)) {
            data["saleDetails"] = [];
            for (let item of this.saleDetails)
                data["saleDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IUpsertSaleModel {
    id?: string;
    saleDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    saleStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    saleNote?: string | undefined;
    staffNote?: string | undefined;
    salePayment?: AddSalePaymentModel;
    saleDetails?: SaleDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class AddSalePaymentModel implements IAddSalePaymentModel {
    id?: string;
    saleId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string | undefined;
    note?: string | undefined;

    constructor(data?: IAddSalePaymentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleId = _data["saleId"];
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): AddSalePaymentModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddSalePaymentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleId"] = this.saleId;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["note"] = this.note;
        return data;
    }
}

export interface IAddSalePaymentModel {
    id?: string;
    saleId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string | undefined;
    note?: string | undefined;
}

export class SaleInfoModel implements ISaleInfoModel {
    id?: string;
    saleDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    saleStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    subTotal?: number;
    grandTotal?: number;
    saleNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    saleStatus?: string;
    paymentStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    customer?: CustomerModel;
    saleDetails?: SaleDetailModel[];
    paymentDetails?: SalePaymentModel[];

    constructor(data?: ISaleInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.saleDate = _data["saleDate"] ? new Date(_data["saleDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.saleStatusId = _data["saleStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.discountType = _data["discountType"];
            this.shippingCost = _data["shippingCost"];
            this.subTotal = _data["subTotal"];
            this.grandTotal = _data["grandTotal"];
            this.saleNote = _data["saleNote"];
            this.staffNote = _data["staffNote"];
            this.warehouseName = _data["warehouseName"];
            this.customerName = _data["customerName"];
            this.saleStatus = _data["saleStatus"];
            this.paymentStatus = _data["paymentStatus"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalDiscount = _data["totalDiscount"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.totalItems = _data["totalItems"];
            this.companyInfo = _data["companyInfo"] ? CompanyInfoModel.fromJS(_data["companyInfo"]) : <any>undefined;
            this.customer = _data["customer"] ? CustomerModel.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["saleDetails"])) {
                this.saleDetails = [] as any;
                for (let item of _data["saleDetails"])
                    this.saleDetails!.push(SaleDetailModel.fromJS(item));
            }
            if (Array.isArray(_data["paymentDetails"])) {
                this.paymentDetails = [] as any;
                for (let item of _data["paymentDetails"])
                    this.paymentDetails!.push(SalePaymentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleDate"] = this.saleDate ? formatDate(this.saleDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["saleStatusId"] = this.saleStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["discountType"] = this.discountType;
        data["shippingCost"] = this.shippingCost;
        data["subTotal"] = this.subTotal;
        data["grandTotal"] = this.grandTotal;
        data["saleNote"] = this.saleNote;
        data["staffNote"] = this.staffNote;
        data["warehouseName"] = this.warehouseName;
        data["customerName"] = this.customerName;
        data["saleStatus"] = this.saleStatus;
        data["paymentStatus"] = this.paymentStatus;
        data["totalQuantity"] = this.totalQuantity;
        data["totalDiscount"] = this.totalDiscount;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["totalItems"] = this.totalItems;
        data["companyInfo"] = this.companyInfo ? this.companyInfo.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.saleDetails)) {
            data["saleDetails"] = [];
            for (let item of this.saleDetails)
                data["saleDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentDetails)) {
            data["paymentDetails"] = [];
            for (let item of this.paymentDetails)
                data["paymentDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaleInfoModel {
    id?: string;
    saleDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    saleStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    subTotal?: number;
    grandTotal?: number;
    saleNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    saleStatus?: string;
    paymentStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    customer?: CustomerModel;
    saleDetails?: SaleDetailModel[];
    paymentDetails?: SalePaymentModel[];
}

export class CreateSaleCommand extends UpsertSaleModel implements ICreateSaleCommand {
    cacheKey?: string;

    constructor(data?: ICreateSaleCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): CreateSaleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSaleCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateSaleCommand extends IUpsertSaleModel {
    cacheKey?: string;
}

export class UpdateSaleCommand extends UpsertSaleModel implements IUpdateSaleCommand {
    cacheKey?: string;

    constructor(data?: IUpdateSaleCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): UpdateSaleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSaleCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateSaleCommand extends IUpsertSaleModel {
    cacheKey?: string;
}

export class PaginatedResponseOfQuotationModel implements IPaginatedResponseOfQuotationModel {
    items?: QuotationModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfQuotationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuotationModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfQuotationModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfQuotationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfQuotationModel {
    items?: QuotationModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class QuotationModel implements IQuotationModel {
    id?: string;
    quotationDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    quotationStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    grandTotal?: number;
    quotationNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    quotationStatus?: string;
    quotationDetails?: QuotationDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IQuotationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotationDate = _data["quotationDate"] ? new Date(_data["quotationDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.quotationStatusId = _data["quotationStatusId"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.discountType = _data["discountType"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.quotationNote = _data["quotationNote"];
            this.warehouseName = _data["warehouseName"];
            this.customerName = _data["customerName"];
            this.quotationStatus = _data["quotationStatus"];
            if (Array.isArray(_data["quotationDetails"])) {
                this.quotationDetails = [] as any;
                for (let item of _data["quotationDetails"])
                    this.quotationDetails!.push(QuotationDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): QuotationModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationDate"] = this.quotationDate ? formatDate(this.quotationDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["quotationStatusId"] = this.quotationStatusId;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["discountType"] = this.discountType;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["quotationNote"] = this.quotationNote;
        data["warehouseName"] = this.warehouseName;
        data["customerName"] = this.customerName;
        data["quotationStatus"] = this.quotationStatus;
        if (Array.isArray(this.quotationDetails)) {
            data["quotationDetails"] = [];
            for (let item of this.quotationDetails)
                data["quotationDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IQuotationModel {
    id?: string;
    quotationDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    quotationStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    grandTotal?: number;
    quotationNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    quotationStatus?: string;
    quotationDetails?: QuotationDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class QuotationDetailModel implements IQuotationDetailModel {
    id?: string;
    quotationId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitPrice?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;

    constructor(data?: IQuotationDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotationId = _data["quotationId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productUnitCost = _data["productUnitCost"];
            this.productUnitPrice = _data["productUnitPrice"];
            this.productUnitId = _data["productUnitId"];
            this.productUnit = _data["productUnit"];
            this.productUnitDiscount = _data["productUnitDiscount"];
            this.quantity = _data["quantity"];
            this.batchNo = _data["batchNo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.netUnitPrice = _data["netUnitPrice"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.totalPrice = _data["totalPrice"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): QuotationDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationId"] = this.quotationId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productUnitCost"] = this.productUnitCost;
        data["productUnitPrice"] = this.productUnitPrice;
        data["productUnitId"] = this.productUnitId;
        data["productUnit"] = this.productUnit;
        data["productUnitDiscount"] = this.productUnitDiscount;
        data["quantity"] = this.quantity;
        data["batchNo"] = this.batchNo;
        data["expiredDate"] = this.expiredDate ? formatDate(this.expiredDate) : <any>undefined;
        data["netUnitPrice"] = this.netUnitPrice;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["totalPrice"] = this.totalPrice;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface IQuotationDetailModel {
    id?: string;
    quotationId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitPrice?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;
}

export class GetQuotationListQuery extends DataGridModel implements IGetQuotationListQuery {
    cacheKey?: string;

    constructor(data?: IGetQuotationListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetQuotationListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetQuotationListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class UpsertQuotationModel implements IUpsertQuotationModel {
    id?: string;
    quotationDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    quotationStatusId?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    quotationNote?: string | undefined;
    quotationDetails?: QuotationDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IUpsertQuotationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotationDate = _data["quotationDate"] ? new Date(_data["quotationDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.quotationStatusId = _data["quotationStatusId"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.quotationNote = _data["quotationNote"];
            if (Array.isArray(_data["quotationDetails"])) {
                this.quotationDetails = [] as any;
                for (let item of _data["quotationDetails"])
                    this.quotationDetails!.push(QuotationDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpsertQuotationModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertQuotationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationDate"] = this.quotationDate ? formatDate(this.quotationDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["quotationStatusId"] = this.quotationStatusId;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["quotationNote"] = this.quotationNote;
        if (Array.isArray(this.quotationDetails)) {
            data["quotationDetails"] = [];
            for (let item of this.quotationDetails)
                data["quotationDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IUpsertQuotationModel {
    id?: string;
    quotationDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    quotationStatusId?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    quotationNote?: string | undefined;
    quotationDetails?: QuotationDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class QuotationInfoModel implements IQuotationInfoModel {
    id?: string;
    quotationDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    quotationStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    subTotal?: number;
    grandTotal?: number;
    quotationNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    quotationStatus?: string;
    paymentStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    customer?: CustomerModel;
    quotationDetails?: QuotationDetailModel[];

    constructor(data?: IQuotationInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotationDate = _data["quotationDate"] ? new Date(_data["quotationDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.customerId = _data["customerId"];
            this.billerId = _data["billerId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.quotationStatusId = _data["quotationStatusId"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.discountType = _data["discountType"];
            this.shippingCost = _data["shippingCost"];
            this.subTotal = _data["subTotal"];
            this.grandTotal = _data["grandTotal"];
            this.quotationNote = _data["quotationNote"];
            this.staffNote = _data["staffNote"];
            this.warehouseName = _data["warehouseName"];
            this.customerName = _data["customerName"];
            this.quotationStatus = _data["quotationStatus"];
            this.paymentStatus = _data["paymentStatus"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalDiscount = _data["totalDiscount"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.totalItems = _data["totalItems"];
            this.companyInfo = _data["companyInfo"] ? CompanyInfoModel.fromJS(_data["companyInfo"]) : <any>undefined;
            this.customer = _data["customer"] ? CustomerModel.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["quotationDetails"])) {
                this.quotationDetails = [] as any;
                for (let item of _data["quotationDetails"])
                    this.quotationDetails!.push(QuotationDetailModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuotationInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationDate"] = this.quotationDate ? formatDate(this.quotationDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["customerId"] = this.customerId;
        data["billerId"] = this.billerId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["quotationStatusId"] = this.quotationStatusId;
        data["paymentStatusId"] = this.paymentStatusId;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["discountType"] = this.discountType;
        data["shippingCost"] = this.shippingCost;
        data["subTotal"] = this.subTotal;
        data["grandTotal"] = this.grandTotal;
        data["quotationNote"] = this.quotationNote;
        data["staffNote"] = this.staffNote;
        data["warehouseName"] = this.warehouseName;
        data["customerName"] = this.customerName;
        data["quotationStatus"] = this.quotationStatus;
        data["paymentStatus"] = this.paymentStatus;
        data["totalQuantity"] = this.totalQuantity;
        data["totalDiscount"] = this.totalDiscount;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["totalItems"] = this.totalItems;
        data["companyInfo"] = this.companyInfo ? this.companyInfo.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.quotationDetails)) {
            data["quotationDetails"] = [];
            for (let item of this.quotationDetails)
                data["quotationDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuotationInfoModel {
    id?: string;
    quotationDate?: Date;
    referenceNo?: string | undefined;
    warehouseId?: string;
    customerId?: string;
    billerId?: string;
    attachmentUrl?: string | undefined;
    quotationStatusId?: string | undefined;
    paymentStatusId?: string | undefined;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    discountType?: DiscountType;
    shippingCost?: number | undefined;
    subTotal?: number;
    grandTotal?: number;
    quotationNote?: string | undefined;
    staffNote?: string | undefined;
    warehouseName?: string;
    customerName?: string;
    quotationStatus?: string;
    paymentStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    customer?: CustomerModel;
    quotationDetails?: QuotationDetailModel[];
}

export class CreateQuotationCommand extends UpsertQuotationModel implements ICreateQuotationCommand {
    cacheKey?: string;

    constructor(data?: ICreateQuotationCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): CreateQuotationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuotationCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateQuotationCommand extends IUpsertQuotationModel {
    cacheKey?: string;
}

export class UpdateQuotationCommand extends UpsertQuotationModel implements IUpdateQuotationCommand {
    cacheKey?: string;

    constructor(data?: IUpdateQuotationCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): UpdateQuotationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuotationCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateQuotationCommand extends IUpsertQuotationModel {
    cacheKey?: string;
}

export class PaginatedResponseOfPurchaseReturnModel implements IPaginatedResponseOfPurchaseReturnModel {
    items?: PurchaseReturnModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfPurchaseReturnModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PurchaseReturnModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfPurchaseReturnModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfPurchaseReturnModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfPurchaseReturnModel {
    items?: PurchaseReturnModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class PurchaseReturnModel implements IPurchaseReturnModel {
    id?: string;
    purchaseId?: string;
    returnDate?: Date;
    referenceNo?: string;
    purchaseReferenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    returnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    supplierName?: string;
    returnStatus?: string;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPurchaseReturnModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseId = _data["purchaseId"];
            this.returnDate = _data["returnDate"] ? new Date(_data["returnDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.purchaseReferenceNo = _data["purchaseReferenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.returnStatusId = _data["returnStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            this.supplierName = _data["supplierName"];
            this.returnStatus = _data["returnStatus"];
            if (Array.isArray(_data["purchaseReturnDetails"])) {
                this.purchaseReturnDetails = [] as any;
                for (let item of _data["purchaseReturnDetails"])
                    this.purchaseReturnDetails!.push(PurchaseReturnDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurchaseReturnModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseReturnModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseId"] = this.purchaseId;
        data["returnDate"] = this.returnDate ? formatDate(this.returnDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["purchaseReferenceNo"] = this.purchaseReferenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["returnStatusId"] = this.returnStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        data["supplierName"] = this.supplierName;
        data["returnStatus"] = this.returnStatus;
        if (Array.isArray(this.purchaseReturnDetails)) {
            data["purchaseReturnDetails"] = [];
            for (let item of this.purchaseReturnDetails)
                data["purchaseReturnDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPurchaseReturnModel {
    id?: string;
    purchaseId?: string;
    returnDate?: Date;
    referenceNo?: string;
    purchaseReferenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    returnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    supplierName?: string;
    returnStatus?: string;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class PurchaseReturnDetailModel implements IPurchaseReturnDetailModel {
    id?: string;
    purchaseReturnId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    purchasedQuantity?: number;
    returnedQuantity?: number;
    stockQuantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitCost?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;

    constructor(data?: IPurchaseReturnDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseReturnId = _data["purchaseReturnId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productUnitCost = _data["productUnitCost"];
            this.productUnitPrice = _data["productUnitPrice"];
            this.productUnitId = _data["productUnitId"];
            this.productUnit = _data["productUnit"];
            this.productUnitDiscount = _data["productUnitDiscount"];
            this.purchasedQuantity = _data["purchasedQuantity"];
            this.returnedQuantity = _data["returnedQuantity"];
            this.stockQuantity = _data["stockQuantity"];
            this.batchNo = _data["batchNo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.netUnitCost = _data["netUnitCost"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.totalPrice = _data["totalPrice"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): PurchaseReturnDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseReturnDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseReturnId"] = this.purchaseReturnId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productUnitCost"] = this.productUnitCost;
        data["productUnitPrice"] = this.productUnitPrice;
        data["productUnitId"] = this.productUnitId;
        data["productUnit"] = this.productUnit;
        data["productUnitDiscount"] = this.productUnitDiscount;
        data["purchasedQuantity"] = this.purchasedQuantity;
        data["returnedQuantity"] = this.returnedQuantity;
        data["stockQuantity"] = this.stockQuantity;
        data["batchNo"] = this.batchNo;
        data["expiredDate"] = this.expiredDate ? formatDate(this.expiredDate) : <any>undefined;
        data["netUnitCost"] = this.netUnitCost;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["totalPrice"] = this.totalPrice;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface IPurchaseReturnDetailModel {
    id?: string;
    purchaseReturnId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    purchasedQuantity?: number;
    returnedQuantity?: number;
    stockQuantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitCost?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;
}

export class GetPurchaseReturnListQuery extends DataGridModel implements IGetPurchaseReturnListQuery {
    cacheKey?: string;

    constructor(data?: IGetPurchaseReturnListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetPurchaseReturnListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseReturnListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetPurchaseReturnListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class PurchaseReturnInfoModel implements IPurchaseReturnInfoModel {
    id?: string;
    purchaseReturnDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseReturnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    note?: string | undefined;
    supplierName?: string;
    purchaseReturnStatus?: string;
    paymentStatusId?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    supplier?: SupplierModel;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];

    constructor(data?: IPurchaseReturnInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseReturnDate = _data["purchaseReturnDate"] ? new Date(_data["purchaseReturnDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.purchaseReturnStatusId = _data["purchaseReturnStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.note = _data["note"];
            this.supplierName = _data["supplierName"];
            this.purchaseReturnStatus = _data["purchaseReturnStatus"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalDiscount = _data["totalDiscount"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.totalItems = _data["totalItems"];
            this.companyInfo = _data["companyInfo"] ? CompanyInfoModel.fromJS(_data["companyInfo"]) : <any>undefined;
            this.supplier = _data["supplier"] ? SupplierModel.fromJS(_data["supplier"]) : <any>undefined;
            if (Array.isArray(_data["purchaseReturnDetails"])) {
                this.purchaseReturnDetails = [] as any;
                for (let item of _data["purchaseReturnDetails"])
                    this.purchaseReturnDetails!.push(PurchaseReturnDetailModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseReturnInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseReturnInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseReturnDate"] = this.purchaseReturnDate ? formatDate(this.purchaseReturnDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["purchaseReturnStatusId"] = this.purchaseReturnStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["note"] = this.note;
        data["supplierName"] = this.supplierName;
        data["purchaseReturnStatus"] = this.purchaseReturnStatus;
        data["paymentStatusId"] = this.paymentStatusId;
        data["totalQuantity"] = this.totalQuantity;
        data["totalDiscount"] = this.totalDiscount;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["totalItems"] = this.totalItems;
        data["companyInfo"] = this.companyInfo ? this.companyInfo.toJSON() : <any>undefined;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        if (Array.isArray(this.purchaseReturnDetails)) {
            data["purchaseReturnDetails"] = [];
            for (let item of this.purchaseReturnDetails)
                data["purchaseReturnDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPurchaseReturnInfoModel {
    id?: string;
    purchaseReturnDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseReturnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    note?: string | undefined;
    supplierName?: string;
    purchaseReturnStatus?: string;
    paymentStatusId?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    supplier?: SupplierModel;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
}

export class CreatePurchaseReturnCommand implements ICreatePurchaseReturnCommand {
    returnDate?: Date;
    referenceNo?: string;
    purchaseId?: string;
    returnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
    cacheKey?: string;

    constructor(data?: ICreatePurchaseReturnCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.returnDate = _data["returnDate"] ? new Date(_data["returnDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.purchaseId = _data["purchaseId"];
            this.returnStatusId = _data["returnStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            if (Array.isArray(_data["purchaseReturnDetails"])) {
                this.purchaseReturnDetails = [] as any;
                for (let item of _data["purchaseReturnDetails"])
                    this.purchaseReturnDetails!.push(PurchaseReturnDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreatePurchaseReturnCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseReturnCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnDate"] = this.returnDate ? formatDate(this.returnDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["purchaseId"] = this.purchaseId;
        data["returnStatusId"] = this.returnStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        if (Array.isArray(this.purchaseReturnDetails)) {
            data["purchaseReturnDetails"] = [];
            for (let item of this.purchaseReturnDetails)
                data["purchaseReturnDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreatePurchaseReturnCommand {
    returnDate?: Date;
    referenceNo?: string;
    purchaseId?: string;
    returnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
    cacheKey?: string;
}

export class UpdatePurchaseReturnCommand implements IUpdatePurchaseReturnCommand {
    id?: string;
    purchaseReturnDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseReturnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
    cacheKey?: string;

    constructor(data?: IUpdatePurchaseReturnCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseReturnDate = _data["purchaseReturnDate"] ? new Date(_data["purchaseReturnDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.purchaseReturnStatusId = _data["purchaseReturnStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            if (Array.isArray(_data["purchaseReturnDetails"])) {
                this.purchaseReturnDetails = [] as any;
                for (let item of _data["purchaseReturnDetails"])
                    this.purchaseReturnDetails!.push(PurchaseReturnDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdatePurchaseReturnCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseReturnCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseReturnDate"] = this.purchaseReturnDate ? formatDate(this.purchaseReturnDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["purchaseReturnStatusId"] = this.purchaseReturnStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        if (Array.isArray(this.purchaseReturnDetails)) {
            data["purchaseReturnDetails"] = [];
            for (let item of this.purchaseReturnDetails)
                data["purchaseReturnDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdatePurchaseReturnCommand {
    id?: string;
    purchaseReturnDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseReturnStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseReturnDetails?: PurchaseReturnDetailModel[];
    cacheKey?: string;
}

export class PaginatedResponseOfPurchasePaymentModel implements IPaginatedResponseOfPurchasePaymentModel {
    items?: PurchasePaymentModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfPurchasePaymentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PurchasePaymentModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfPurchasePaymentModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfPurchasePaymentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfPurchasePaymentModel {
    items?: PurchasePaymentModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class PurchasePaymentModel implements IPurchasePaymentModel {
    id?: string;
    purchaseId?: string;
    paymentDate?: Date;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string | undefined;
    paymentTypeName?: string;
    createdBy?: string;
    note?: string | undefined;
    paymentDateString?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPurchasePaymentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseId = _data["purchaseId"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.paymentTypeName = _data["paymentTypeName"];
            this.createdBy = _data["createdBy"];
            this.note = _data["note"];
            this.paymentDateString = _data["paymentDateString"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurchasePaymentModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasePaymentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseId"] = this.purchaseId;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["paymentTypeName"] = this.paymentTypeName;
        data["createdBy"] = this.createdBy;
        data["note"] = this.note;
        data["paymentDateString"] = this.paymentDateString;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPurchasePaymentModel {
    id?: string;
    purchaseId?: string;
    paymentDate?: Date;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string | undefined;
    paymentTypeName?: string;
    createdBy?: string;
    note?: string | undefined;
    paymentDateString?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetPurchasePaymentListQuery extends DataGridModel implements IGetPurchasePaymentListQuery {
    cacheKey?: string;
    purchaseId?: string;

    constructor(data?: IGetPurchasePaymentListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
            this.purchaseId = _data["purchaseId"];
        }
    }

    static override fromJS(data: any): GetPurchasePaymentListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchasePaymentListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        data["purchaseId"] = this.purchaseId;
        super.toJSON(data);
        return data;
    }
}

export interface IGetPurchasePaymentListQuery extends IDataGridModel {
    cacheKey?: string;
    purchaseId?: string;
}

export class GetPaymentListByPurchaseIdQuery implements IGetPaymentListByPurchaseIdQuery {
    cacheKey?: string;
    purchaseId?: string;
    allowCache?: boolean | undefined;

    constructor(data?: IGetPaymentListByPurchaseIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cacheKey = _data["cacheKey"];
            this.purchaseId = _data["purchaseId"];
            this.allowCache = _data["allowCache"];
        }
    }

    static fromJS(data: any): GetPaymentListByPurchaseIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaymentListByPurchaseIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        data["purchaseId"] = this.purchaseId;
        data["allowCache"] = this.allowCache;
        return data;
    }
}

export interface IGetPaymentListByPurchaseIdQuery {
    cacheKey?: string;
    purchaseId?: string;
    allowCache?: boolean | undefined;
}

export class CreatePurchasePaymentCommand implements ICreatePurchasePaymentCommand {
    purchaseId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;

    constructor(data?: ICreatePurchasePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseId = _data["purchaseId"];
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): CreatePurchasePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchasePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseId"] = this.purchaseId;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["note"] = this.note;
        return data;
    }
}

export interface ICreatePurchasePaymentCommand {
    purchaseId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;
}

export class UpdatePurchasePaymentCommand implements IUpdatePurchasePaymentCommand {
    id!: string;
    purchaseId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdatePurchasePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseId = _data["purchaseId"];
            this.receivedAmount = _data["receivedAmount"];
            this.payingAmount = _data["payingAmount"];
            this.changeAmount = _data["changeAmount"];
            this.paymentType = _data["paymentType"];
            this.note = _data["note"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdatePurchasePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchasePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseId"] = this.purchaseId;
        data["receivedAmount"] = this.receivedAmount;
        data["payingAmount"] = this.payingAmount;
        data["changeAmount"] = this.changeAmount;
        data["paymentType"] = this.paymentType;
        data["note"] = this.note;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdatePurchasePaymentCommand {
    id: string;
    purchaseId?: string;
    receivedAmount?: number;
    payingAmount?: number;
    changeAmount?: number;
    paymentType?: string;
    note?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfPurchaseModel implements IPaginatedResponseOfPurchaseModel {
    items?: PurchaseModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfPurchaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PurchaseModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfPurchaseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfPurchaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfPurchaseModel {
    items?: PurchaseModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class PurchaseModel implements IPurchaseModel {
    id?: string;
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    note?: string | undefined;
    supplierName?: string;
    purchaseStatus?: string;
    paymentStatus?: string;
    paymentStatusTag?: string;
    purchaseDetails?: PurchaseDetailModel[];
    paymentDetails?: PurchasePaymentModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPurchaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.purchaseStatusId = _data["purchaseStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.note = _data["note"];
            this.supplierName = _data["supplierName"];
            this.purchaseStatus = _data["purchaseStatus"];
            this.paymentStatus = _data["paymentStatus"];
            this.paymentStatusTag = _data["paymentStatusTag"];
            if (Array.isArray(_data["purchaseDetails"])) {
                this.purchaseDetails = [] as any;
                for (let item of _data["purchaseDetails"])
                    this.purchaseDetails!.push(PurchaseDetailModel.fromJS(item));
            }
            if (Array.isArray(_data["paymentDetails"])) {
                this.paymentDetails = [] as any;
                for (let item of _data["paymentDetails"])
                    this.paymentDetails!.push(PurchasePaymentModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurchaseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseDate"] = this.purchaseDate ? formatDate(this.purchaseDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["purchaseStatusId"] = this.purchaseStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["note"] = this.note;
        data["supplierName"] = this.supplierName;
        data["purchaseStatus"] = this.purchaseStatus;
        data["paymentStatus"] = this.paymentStatus;
        data["paymentStatusTag"] = this.paymentStatusTag;
        if (Array.isArray(this.purchaseDetails)) {
            data["purchaseDetails"] = [];
            for (let item of this.purchaseDetails)
                data["purchaseDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentDetails)) {
            data["paymentDetails"] = [];
            for (let item of this.paymentDetails)
                data["paymentDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPurchaseModel {
    id?: string;
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    note?: string | undefined;
    supplierName?: string;
    purchaseStatus?: string;
    paymentStatus?: string;
    paymentStatusTag?: string;
    purchaseDetails?: PurchaseDetailModel[];
    paymentDetails?: PurchasePaymentModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class PurchaseDetailModel implements IPurchaseDetailModel {
    id?: string;
    purchaseId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitCost?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;

    constructor(data?: IPurchaseDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseId = _data["purchaseId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productUnitCost = _data["productUnitCost"];
            this.productUnitPrice = _data["productUnitPrice"];
            this.productUnitId = _data["productUnitId"];
            this.productUnit = _data["productUnit"];
            this.productUnitDiscount = _data["productUnitDiscount"];
            this.quantity = _data["quantity"];
            this.batchNo = _data["batchNo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.netUnitCost = _data["netUnitCost"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.totalPrice = _data["totalPrice"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): PurchaseDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseId"] = this.purchaseId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productUnitCost"] = this.productUnitCost;
        data["productUnitPrice"] = this.productUnitPrice;
        data["productUnitId"] = this.productUnitId;
        data["productUnit"] = this.productUnit;
        data["productUnitDiscount"] = this.productUnitDiscount;
        data["quantity"] = this.quantity;
        data["batchNo"] = this.batchNo;
        data["expiredDate"] = this.expiredDate ? formatDate(this.expiredDate) : <any>undefined;
        data["netUnitCost"] = this.netUnitCost;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["totalPrice"] = this.totalPrice;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface IPurchaseDetailModel {
    id?: string;
    purchaseId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitCost?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;
}

export class GetPurchaseListQuery extends DataGridModel implements IGetPurchaseListQuery {
    cacheKey?: string;

    constructor(data?: IGetPurchaseListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetPurchaseListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetPurchaseListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class PurchaseInfoModel implements IPurchaseInfoModel {
    id?: string;
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    note?: string | undefined;
    supplierName?: string;
    purchaseStatus?: string;
    paymentStatusId?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    supplier?: SupplierModel;
    purchaseDetails?: PurchaseDetailModel[];
    paymentDetails?: PurchasePaymentModel[];

    constructor(data?: IPurchaseInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.purchaseStatusId = _data["purchaseStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.paidAmount = _data["paidAmount"];
            this.dueAmount = _data["dueAmount"];
            this.note = _data["note"];
            this.supplierName = _data["supplierName"];
            this.purchaseStatus = _data["purchaseStatus"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalDiscount = _data["totalDiscount"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.totalItems = _data["totalItems"];
            this.companyInfo = _data["companyInfo"] ? CompanyInfoModel.fromJS(_data["companyInfo"]) : <any>undefined;
            this.supplier = _data["supplier"] ? SupplierModel.fromJS(_data["supplier"]) : <any>undefined;
            if (Array.isArray(_data["purchaseDetails"])) {
                this.purchaseDetails = [] as any;
                for (let item of _data["purchaseDetails"])
                    this.purchaseDetails!.push(PurchaseDetailModel.fromJS(item));
            }
            if (Array.isArray(_data["paymentDetails"])) {
                this.paymentDetails = [] as any;
                for (let item of _data["paymentDetails"])
                    this.paymentDetails!.push(PurchasePaymentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseDate"] = this.purchaseDate ? formatDate(this.purchaseDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["purchaseStatusId"] = this.purchaseStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["paidAmount"] = this.paidAmount;
        data["dueAmount"] = this.dueAmount;
        data["note"] = this.note;
        data["supplierName"] = this.supplierName;
        data["purchaseStatus"] = this.purchaseStatus;
        data["paymentStatusId"] = this.paymentStatusId;
        data["totalQuantity"] = this.totalQuantity;
        data["totalDiscount"] = this.totalDiscount;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["totalItems"] = this.totalItems;
        data["companyInfo"] = this.companyInfo ? this.companyInfo.toJSON() : <any>undefined;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        if (Array.isArray(this.purchaseDetails)) {
            data["purchaseDetails"] = [];
            for (let item of this.purchaseDetails)
                data["purchaseDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentDetails)) {
            data["paymentDetails"] = [];
            for (let item of this.paymentDetails)
                data["paymentDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPurchaseInfoModel {
    id?: string;
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    paidAmount?: number;
    dueAmount?: number;
    note?: string | undefined;
    supplierName?: string;
    purchaseStatus?: string;
    paymentStatusId?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    companyInfo?: CompanyInfoModel;
    supplier?: SupplierModel;
    purchaseDetails?: PurchaseDetailModel[];
    paymentDetails?: PurchasePaymentModel[];
}

export class CreatePurchaseCommand implements ICreatePurchaseCommand {
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseDetails?: PurchaseDetailModel[];
    cacheKey?: string;

    constructor(data?: ICreatePurchaseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.purchaseStatusId = _data["purchaseStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            if (Array.isArray(_data["purchaseDetails"])) {
                this.purchaseDetails = [] as any;
                for (let item of _data["purchaseDetails"])
                    this.purchaseDetails!.push(PurchaseDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreatePurchaseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseDate"] = this.purchaseDate ? formatDate(this.purchaseDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["purchaseStatusId"] = this.purchaseStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        if (Array.isArray(this.purchaseDetails)) {
            data["purchaseDetails"] = [];
            for (let item of this.purchaseDetails)
                data["purchaseDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreatePurchaseCommand {
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseDetails?: PurchaseDetailModel[];
    cacheKey?: string;
}

export class UpdatePurchaseCommand implements IUpdatePurchaseCommand {
    id?: string;
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseDetails?: PurchaseDetailModel[];
    cacheKey?: string;

    constructor(data?: IUpdatePurchaseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.supplierId = _data["supplierId"];
            this.purchaseStatusId = _data["purchaseStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            if (Array.isArray(_data["purchaseDetails"])) {
                this.purchaseDetails = [] as any;
                for (let item of _data["purchaseDetails"])
                    this.purchaseDetails!.push(PurchaseDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdatePurchaseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaseDate"] = this.purchaseDate ? formatDate(this.purchaseDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["supplierId"] = this.supplierId;
        data["purchaseStatusId"] = this.purchaseStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        if (Array.isArray(this.purchaseDetails)) {
            data["purchaseDetails"] = [];
            for (let item of this.purchaseDetails)
                data["purchaseDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdatePurchaseCommand {
    id?: string;
    purchaseDate?: Date;
    referenceNo?: string;
    warehouseId?: string;
    supplierId?: string;
    purchaseStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    purchaseDetails?: PurchaseDetailModel[];
    cacheKey?: string;
}

export class PaginatedResponseOfProductTransferModel implements IPaginatedResponseOfProductTransferModel {
    items?: ProductTransferModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfProductTransferModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductTransferModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfProductTransferModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfProductTransferModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfProductTransferModel {
    items?: ProductTransferModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class ProductTransferModel implements IProductTransferModel {
    id?: string;
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    supplierId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    transferStatus?: string;
    fromWarehouse?: string;
    toWarehouse?: string;
    productTransferDetails?: ProductTransferDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IProductTransferModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transferDate = _data["transferDate"] ? new Date(_data["transferDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.fromWarehouseId = _data["fromWarehouseId"];
            this.toWarehouseId = _data["toWarehouseId"];
            this.supplierId = _data["supplierId"];
            this.transferStatusId = _data["transferStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            this.transferStatus = _data["transferStatus"];
            this.fromWarehouse = _data["fromWarehouse"];
            this.toWarehouse = _data["toWarehouse"];
            if (Array.isArray(_data["productTransferDetails"])) {
                this.productTransferDetails = [] as any;
                for (let item of _data["productTransferDetails"])
                    this.productTransferDetails!.push(ProductTransferDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductTransferModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTransferModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transferDate"] = this.transferDate ? formatDate(this.transferDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["fromWarehouseId"] = this.fromWarehouseId;
        data["toWarehouseId"] = this.toWarehouseId;
        data["supplierId"] = this.supplierId;
        data["transferStatusId"] = this.transferStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        data["transferStatus"] = this.transferStatus;
        data["fromWarehouse"] = this.fromWarehouse;
        data["toWarehouse"] = this.toWarehouse;
        if (Array.isArray(this.productTransferDetails)) {
            data["productTransferDetails"] = [];
            for (let item of this.productTransferDetails)
                data["productTransferDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IProductTransferModel {
    id?: string;
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    supplierId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    transferStatus?: string;
    fromWarehouse?: string;
    toWarehouse?: string;
    productTransferDetails?: ProductTransferDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class ProductTransferDetailModel implements IProductTransferDetailModel {
    id?: string;
    productTransferId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitCost?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;

    constructor(data?: IProductTransferDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productTransferId = _data["productTransferId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productUnitCost = _data["productUnitCost"];
            this.productUnitPrice = _data["productUnitPrice"];
            this.productUnitId = _data["productUnitId"];
            this.productUnit = _data["productUnit"];
            this.productUnitDiscount = _data["productUnitDiscount"];
            this.quantity = _data["quantity"];
            this.batchNo = _data["batchNo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.netUnitCost = _data["netUnitCost"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.totalPrice = _data["totalPrice"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): ProductTransferDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTransferDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productTransferId"] = this.productTransferId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productUnitCost"] = this.productUnitCost;
        data["productUnitPrice"] = this.productUnitPrice;
        data["productUnitId"] = this.productUnitId;
        data["productUnit"] = this.productUnit;
        data["productUnitDiscount"] = this.productUnitDiscount;
        data["quantity"] = this.quantity;
        data["batchNo"] = this.batchNo;
        data["expiredDate"] = this.expiredDate ? formatDate(this.expiredDate) : <any>undefined;
        data["netUnitCost"] = this.netUnitCost;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["totalPrice"] = this.totalPrice;
        data["remarks"] = this.remarks;
        return data;
    }
}

export interface IProductTransferDetailModel {
    id?: string;
    productTransferId?: string;
    productId?: string;
    productCode?: string;
    productName?: string;
    productUnitCost?: number;
    productUnitPrice?: number;
    productUnitId?: string;
    productUnit?: number;
    productUnitDiscount?: number;
    quantity?: number;
    batchNo?: string;
    expiredDate?: Date | undefined;
    netUnitCost?: number;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number;
    taxMethod?: TaxMethod;
    taxRate?: number;
    taxAmount?: number;
    totalPrice?: number;
    remarks?: string | undefined;
}

export class GetProductTransferListQuery extends DataGridModel implements IGetProductTransferListQuery {
    cacheKey?: string;

    constructor(data?: IGetProductTransferListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetProductTransferListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductTransferListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetProductTransferListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class ProductTransferInfoModel implements IProductTransferInfoModel {
    id?: string;
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    transferStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    fromWarehouse?: string;
    fromWarehousePhone?: string;
    fromWarehouseEmail?: string;
    toWarehouse?: string;
    toWarehousePhone?: string;
    toWarehouseEmail?: string;
    productTransferDetails?: ProductTransferDetailModel[];

    constructor(data?: IProductTransferInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transferDate = _data["transferDate"] ? new Date(_data["transferDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.fromWarehouseId = _data["fromWarehouseId"];
            this.toWarehouseId = _data["toWarehouseId"];
            this.transferStatusId = _data["transferStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            this.transferStatus = _data["transferStatus"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalDiscount = _data["totalDiscount"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.totalItems = _data["totalItems"];
            this.fromWarehouse = _data["fromWarehouse"];
            this.fromWarehousePhone = _data["fromWarehousePhone"];
            this.fromWarehouseEmail = _data["fromWarehouseEmail"];
            this.toWarehouse = _data["toWarehouse"];
            this.toWarehousePhone = _data["toWarehousePhone"];
            this.toWarehouseEmail = _data["toWarehouseEmail"];
            if (Array.isArray(_data["productTransferDetails"])) {
                this.productTransferDetails = [] as any;
                for (let item of _data["productTransferDetails"])
                    this.productTransferDetails!.push(ProductTransferDetailModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTransferInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTransferInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transferDate"] = this.transferDate ? formatDate(this.transferDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["fromWarehouseId"] = this.fromWarehouseId;
        data["toWarehouseId"] = this.toWarehouseId;
        data["transferStatusId"] = this.transferStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        data["transferStatus"] = this.transferStatus;
        data["totalQuantity"] = this.totalQuantity;
        data["totalDiscount"] = this.totalDiscount;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["totalItems"] = this.totalItems;
        data["fromWarehouse"] = this.fromWarehouse;
        data["fromWarehousePhone"] = this.fromWarehousePhone;
        data["fromWarehouseEmail"] = this.fromWarehouseEmail;
        data["toWarehouse"] = this.toWarehouse;
        data["toWarehousePhone"] = this.toWarehousePhone;
        data["toWarehouseEmail"] = this.toWarehouseEmail;
        if (Array.isArray(this.productTransferDetails)) {
            data["productTransferDetails"] = [];
            for (let item of this.productTransferDetails)
                data["productTransferDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTransferInfoModel {
    id?: string;
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    transferStatus?: string;
    totalQuantity?: number;
    totalDiscount?: number;
    totalTaxAmount?: number;
    totalItems?: string;
    fromWarehouse?: string;
    fromWarehousePhone?: string;
    fromWarehouseEmail?: string;
    toWarehouse?: string;
    toWarehousePhone?: string;
    toWarehouseEmail?: string;
    productTransferDetails?: ProductTransferDetailModel[];
}

export class CreateProductTransferCommand implements ICreateProductTransferCommand {
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    productTransferDetails?: ProductTransferDetailModel[];
    cacheKey?: string;

    constructor(data?: ICreateProductTransferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferDate = _data["transferDate"] ? new Date(_data["transferDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.fromWarehouseId = _data["fromWarehouseId"];
            this.toWarehouseId = _data["toWarehouseId"];
            this.transferStatusId = _data["transferStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            if (Array.isArray(_data["productTransferDetails"])) {
                this.productTransferDetails = [] as any;
                for (let item of _data["productTransferDetails"])
                    this.productTransferDetails!.push(ProductTransferDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateProductTransferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTransferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferDate"] = this.transferDate ? formatDate(this.transferDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["fromWarehouseId"] = this.fromWarehouseId;
        data["toWarehouseId"] = this.toWarehouseId;
        data["transferStatusId"] = this.transferStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        if (Array.isArray(this.productTransferDetails)) {
            data["productTransferDetails"] = [];
            for (let item of this.productTransferDetails)
                data["productTransferDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateProductTransferCommand {
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    productTransferDetails?: ProductTransferDetailModel[];
    cacheKey?: string;
}

export class UpdateProductTransferCommand implements IUpdateProductTransferCommand {
    id?: string;
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    productTransferDetails?: ProductTransferDetailModel[];
    cacheKey?: string;

    constructor(data?: IUpdateProductTransferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transferDate = _data["transferDate"] ? new Date(_data["transferDate"].toString()) : <any>undefined;
            this.referenceNo = _data["referenceNo"];
            this.fromWarehouseId = _data["fromWarehouseId"];
            this.toWarehouseId = _data["toWarehouseId"];
            this.transferStatusId = _data["transferStatusId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.subTotal = _data["subTotal"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountType = _data["discountType"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.shippingCost = _data["shippingCost"];
            this.grandTotal = _data["grandTotal"];
            this.note = _data["note"];
            if (Array.isArray(_data["productTransferDetails"])) {
                this.productTransferDetails = [] as any;
                for (let item of _data["productTransferDetails"])
                    this.productTransferDetails!.push(ProductTransferDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateProductTransferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTransferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transferDate"] = this.transferDate ? formatDate(this.transferDate) : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["fromWarehouseId"] = this.fromWarehouseId;
        data["toWarehouseId"] = this.toWarehouseId;
        data["transferStatusId"] = this.transferStatusId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["subTotal"] = this.subTotal;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountType"] = this.discountType;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["shippingCost"] = this.shippingCost;
        data["grandTotal"] = this.grandTotal;
        data["note"] = this.note;
        if (Array.isArray(this.productTransferDetails)) {
            data["productTransferDetails"] = [];
            for (let item of this.productTransferDetails)
                data["productTransferDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateProductTransferCommand {
    id?: string;
    transferDate?: Date;
    referenceNo?: string;
    fromWarehouseId?: string;
    toWarehouseId?: string;
    transferStatusId?: string;
    attachmentUrl?: string | undefined;
    subTotal?: number;
    taxRate?: number | undefined;
    taxAmount?: number | undefined;
    discountType?: DiscountType;
    discountRate?: number | undefined;
    discountAmount?: number | undefined;
    shippingCost?: number | undefined;
    grandTotal?: number;
    note?: string | undefined;
    productTransferDetails?: ProductTransferDetailModel[];
    cacheKey?: string;
}

export class PaginatedResponseOfBrandModel implements IPaginatedResponseOfBrandModel {
    items?: BrandModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfBrandModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfBrandModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfBrandModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfBrandModel {
    items?: BrandModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class BrandModel implements IBrandModel {
    id?: string;
    name?: string;
    photoUrl?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IBrandModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrandModel {
        data = typeof data === 'object' ? data : {};
        let result = new BrandModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IBrandModel {
    id?: string;
    name?: string;
    photoUrl?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetBrandListQuery extends DataGridModel implements IGetBrandListQuery {
    cacheKey?: string;

    constructor(data?: IGetBrandListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetBrandListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrandListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetBrandListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateBrandCommand implements ICreateBrandCommand {
    name!: string;
    photoUrl?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateBrandCommand {
    name: string;
    photoUrl?: string | undefined;
    cacheKey?: string;
}

export class UpdateBrandCommand implements IUpdateBrandCommand {
    id?: string;
    name!: string;
    photoUrl?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateBrandCommand {
    id?: string;
    name: string;
    photoUrl?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfCategoryModel implements IPaginatedResponseOfCategoryModel {
    items?: CategoryModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfCategoryModel {
    items?: CategoryModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class CategoryModel implements ICategoryModel {
    id?: string;
    name?: string;
    description?: string | undefined;
    parentId?: string | undefined;
    parentCategory?: string;
    photoUrl?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.parentId = _data["parentId"];
            this.parentCategory = _data["parentCategory"];
            this.photoUrl = _data["photoUrl"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["parentCategory"] = this.parentCategory;
        data["photoUrl"] = this.photoUrl;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICategoryModel {
    id?: string;
    name?: string;
    description?: string | undefined;
    parentId?: string | undefined;
    parentCategory?: string;
    photoUrl?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetCategoryListQuery extends DataGridModel implements IGetCategoryListQuery {
    cacheKey?: string;

    constructor(data?: IGetCategoryListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetCategoryListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetCategoryListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    name!: string;
    description?: string;
    photoUrl?: string;
    parentId?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.photoUrl = _data["photoUrl"];
            this.parentId = _data["parentId"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["photoUrl"] = this.photoUrl;
        data["parentId"] = this.parentId;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCategoryCommand {
    name: string;
    description?: string;
    photoUrl?: string;
    parentId?: string | undefined;
    cacheKey?: string;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    id?: string;
    name!: string;
    description?: string;
    photoUrl?: string;
    parentId?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.photoUrl = _data["photoUrl"];
            this.parentId = _data["parentId"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["photoUrl"] = this.photoUrl;
        data["parentId"] = this.parentId;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    id?: string;
    name: string;
    description?: string;
    photoUrl?: string;
    parentId?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfCountStockModel implements IPaginatedResponseOfCountStockModel {
    items?: CountStockModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfCountStockModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountStockModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfCountStockModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfCountStockModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfCountStockModel {
    items?: CountStockModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class CountStockModel implements ICountStockModel {
    id?: string;
    referenceNo?: string;
    warehouseId?: string;
    warehouse?: string;
    countingDate?: Date;
    type?: CountStockType;
    typeName?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ICountStockModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.warehouse = _data["warehouse"];
            this.countingDate = _data["countingDate"] ? new Date(_data["countingDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): CountStockModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountStockModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["warehouse"] = this.warehouse;
        data["countingDate"] = this.countingDate ? this.countingDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ICountStockModel {
    id?: string;
    referenceNo?: string;
    warehouseId?: string;
    warehouse?: string;
    countingDate?: Date;
    type?: CountStockType;
    typeName?: string;
    optionsDataSources?: { [key: string]: any; };
}

export enum CountStockType {
    Full = 1,
    Partial = 2,
}

export class GetCountStockListQuery extends DataGridModel implements IGetCountStockListQuery {
    cacheKey?: string;

    constructor(data?: IGetCountStockListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetCountStockListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountStockListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetCountStockListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateCountStockCommand implements ICreateCountStockCommand {
    warehouseId?: string;
    type?: CountStockType;
    categoryIds?: string[];
    brandIds?: string[];
    cacheKey?: string;

    constructor(data?: ICreateCountStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.warehouseId = _data["warehouseId"];
            this.type = _data["type"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["brandIds"])) {
                this.brandIds = [] as any;
                for (let item of _data["brandIds"])
                    this.brandIds!.push(item);
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateCountStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseId"] = this.warehouseId;
        data["type"] = this.type;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.brandIds)) {
            data["brandIds"] = [];
            for (let item of this.brandIds)
                data["brandIds"].push(item);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateCountStockCommand {
    warehouseId?: string;
    type?: CountStockType;
    categoryIds?: string[];
    brandIds?: string[];
    cacheKey?: string;
}

export class UpdateCountStockCommand implements IUpdateCountStockCommand {
    id!: string;
    warehouseId?: string;
    countingDate?: Date;
    cacheKey?: string;

    constructor(data?: IUpdateCountStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.warehouseId = _data["warehouseId"];
            this.countingDate = _data["countingDate"] ? new Date(_data["countingDate"].toString()) : <any>undefined;
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateCountStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["warehouseId"] = this.warehouseId;
        data["countingDate"] = this.countingDate ? this.countingDate.toISOString() : <any>undefined;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateCountStockCommand {
    id: string;
    warehouseId?: string;
    countingDate?: Date;
    cacheKey?: string;
}

export class PaginatedResponseOfProductAdjustmentModel implements IPaginatedResponseOfProductAdjustmentModel {
    items?: ProductAdjustmentModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfProductAdjustmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAdjustmentModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfProductAdjustmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfProductAdjustmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfProductAdjustmentModel {
    items?: ProductAdjustmentModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class ProductAdjustmentModel implements IProductAdjustmentModel {
    id?: string;
    referenceNo?: string;
    warehouseId?: string;
    attachmentUrl?: string | undefined;
    note?: string | undefined;
    adjDate?: Date;
    totalQuantity?: number;
    warehouse?: string;
    productAdjustmentDetails?: ProductAdjustmentDetailModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IProductAdjustmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.note = _data["note"];
            this.adjDate = _data["adjDate"] ? new Date(_data["adjDate"].toString()) : <any>undefined;
            this.totalQuantity = _data["totalQuantity"];
            this.warehouse = _data["warehouse"];
            if (Array.isArray(_data["productAdjustmentDetails"])) {
                this.productAdjustmentDetails = [] as any;
                for (let item of _data["productAdjustmentDetails"])
                    this.productAdjustmentDetails!.push(ProductAdjustmentDetailModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductAdjustmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAdjustmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["note"] = this.note;
        data["adjDate"] = this.adjDate ? this.adjDate.toISOString() : <any>undefined;
        data["totalQuantity"] = this.totalQuantity;
        data["warehouse"] = this.warehouse;
        if (Array.isArray(this.productAdjustmentDetails)) {
            data["productAdjustmentDetails"] = [];
            for (let item of this.productAdjustmentDetails)
                data["productAdjustmentDetails"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IProductAdjustmentModel {
    id?: string;
    referenceNo?: string;
    warehouseId?: string;
    attachmentUrl?: string | undefined;
    note?: string | undefined;
    adjDate?: Date;
    totalQuantity?: number;
    warehouse?: string;
    productAdjustmentDetails?: ProductAdjustmentDetailModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class ProductAdjustmentDetailModel implements IProductAdjustmentDetailModel {
    id?: string;
    productAdjustmentId?: string;
    productId?: string;
    productName?: string;
    productCode?: string;
    unitCost?: number;
    quantity?: number;
    currentStock?: number;
    actionType?: ProductAdjAction;

    constructor(data?: IProductAdjustmentDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productAdjustmentId = _data["productAdjustmentId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.unitCost = _data["unitCost"];
            this.quantity = _data["quantity"];
            this.currentStock = _data["currentStock"];
            this.actionType = _data["actionType"];
        }
    }

    static fromJS(data: any): ProductAdjustmentDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAdjustmentDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productAdjustmentId"] = this.productAdjustmentId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["unitCost"] = this.unitCost;
        data["quantity"] = this.quantity;
        data["currentStock"] = this.currentStock;
        data["actionType"] = this.actionType;
        return data;
    }
}

export interface IProductAdjustmentDetailModel {
    id?: string;
    productAdjustmentId?: string;
    productId?: string;
    productName?: string;
    productCode?: string;
    unitCost?: number;
    quantity?: number;
    currentStock?: number;
    actionType?: ProductAdjAction;
}

export enum ProductAdjAction {
    Addition = 1,
    Subtraction = 2,
}

export class GetProductAdjustmentListQuery extends DataGridModel implements IGetProductAdjustmentListQuery {
    cacheKey?: string;

    constructor(data?: IGetProductAdjustmentListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetProductAdjustmentListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductAdjustmentListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetProductAdjustmentListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateProductAdjustmentCommand implements ICreateProductAdjustmentCommand {
    warehouseId?: string;
    attachmentUrl?: string | undefined;
    note?: string | undefined;
    adjDate?: Date;
    productAdjustmentDetails?: ProductAdjustmentDetailModel[];
    cacheKey?: string;

    constructor(data?: ICreateProductAdjustmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.warehouseId = _data["warehouseId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.note = _data["note"];
            this.adjDate = _data["adjDate"] ? new Date(_data["adjDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["productAdjustmentDetails"])) {
                this.productAdjustmentDetails = [] as any;
                for (let item of _data["productAdjustmentDetails"])
                    this.productAdjustmentDetails!.push(ProductAdjustmentDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateProductAdjustmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAdjustmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseId"] = this.warehouseId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["note"] = this.note;
        data["adjDate"] = this.adjDate ? this.adjDate.toISOString() : <any>undefined;
        if (Array.isArray(this.productAdjustmentDetails)) {
            data["productAdjustmentDetails"] = [];
            for (let item of this.productAdjustmentDetails)
                data["productAdjustmentDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateProductAdjustmentCommand {
    warehouseId?: string;
    attachmentUrl?: string | undefined;
    note?: string | undefined;
    adjDate?: Date;
    productAdjustmentDetails?: ProductAdjustmentDetailModel[];
    cacheKey?: string;
}

export class UpdateProductAdjustmentCommand implements IUpdateProductAdjustmentCommand {
    id!: string;
    warehouseId?: string;
    attachmentUrl?: string | undefined;
    note?: string | undefined;
    adjDate?: Date;
    productAdjustmentDetails?: ProductAdjustmentDetailModel[];
    cacheKey?: string;

    constructor(data?: IUpdateProductAdjustmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.warehouseId = _data["warehouseId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.note = _data["note"];
            this.adjDate = _data["adjDate"] ? new Date(_data["adjDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["productAdjustmentDetails"])) {
                this.productAdjustmentDetails = [] as any;
                for (let item of _data["productAdjustmentDetails"])
                    this.productAdjustmentDetails!.push(ProductAdjustmentDetailModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateProductAdjustmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAdjustmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["warehouseId"] = this.warehouseId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["note"] = this.note;
        data["adjDate"] = this.adjDate ? this.adjDate.toISOString() : <any>undefined;
        if (Array.isArray(this.productAdjustmentDetails)) {
            data["productAdjustmentDetails"] = [];
            for (let item of this.productAdjustmentDetails)
                data["productAdjustmentDetails"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateProductAdjustmentCommand {
    id: string;
    warehouseId?: string;
    attachmentUrl?: string | undefined;
    note?: string | undefined;
    adjDate?: Date;
    productAdjustmentDetails?: ProductAdjustmentDetailModel[];
    cacheKey?: string;
}

export class PaginatedResponseOfProductModel implements IPaginatedResponseOfProductModel {
    items?: ProductModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfProductModel {
    items?: ProductModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class ProductModel implements IProductModel {
    id?: string;
    name?: string;
    categoryId?: string;
    productTypeId?: string;
    brandId?: string | undefined;
    code?: string | undefined;
    sku?: string | undefined;
    costPrice?: number | undefined;
    salePrice?: number;
    wholesalePrice?: number | undefined;
    unit?: string | undefined;
    saleUnit?: string | undefined;
    purchaseUnit?: string | undefined;
    alertQuantity?: number | undefined;
    barCodeType?: string | undefined;
    qrCodeType?: string | undefined;
    taxMethod?: TaxMethod;
    taxRate?: number;
    discountType?: DiscountType;
    discount?: number;
    description?: string | undefined;
    isActive?: boolean;
    photoUrls?: string[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.categoryId = _data["categoryId"];
            this.productTypeId = _data["productTypeId"];
            this.brandId = _data["brandId"];
            this.code = _data["code"];
            this.sku = _data["sku"];
            this.costPrice = _data["costPrice"];
            this.salePrice = _data["salePrice"];
            this.wholesalePrice = _data["wholesalePrice"];
            this.unit = _data["unit"];
            this.saleUnit = _data["saleUnit"];
            this.purchaseUnit = _data["purchaseUnit"];
            this.alertQuantity = _data["alertQuantity"];
            this.barCodeType = _data["barCodeType"];
            this.qrCodeType = _data["qrCodeType"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.discountType = _data["discountType"];
            this.discount = _data["discount"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["photoUrls"])) {
                this.photoUrls = [] as any;
                for (let item of _data["photoUrls"])
                    this.photoUrls!.push(item);
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["productTypeId"] = this.productTypeId;
        data["brandId"] = this.brandId;
        data["code"] = this.code;
        data["sku"] = this.sku;
        data["costPrice"] = this.costPrice;
        data["salePrice"] = this.salePrice;
        data["wholesalePrice"] = this.wholesalePrice;
        data["unit"] = this.unit;
        data["saleUnit"] = this.saleUnit;
        data["purchaseUnit"] = this.purchaseUnit;
        data["alertQuantity"] = this.alertQuantity;
        data["barCodeType"] = this.barCodeType;
        data["qrCodeType"] = this.qrCodeType;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["discountType"] = this.discountType;
        data["discount"] = this.discount;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.photoUrls)) {
            data["photoUrls"] = [];
            for (let item of this.photoUrls)
                data["photoUrls"].push(item);
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IProductModel {
    id?: string;
    name?: string;
    categoryId?: string;
    productTypeId?: string;
    brandId?: string | undefined;
    code?: string | undefined;
    sku?: string | undefined;
    costPrice?: number | undefined;
    salePrice?: number;
    wholesalePrice?: number | undefined;
    unit?: string | undefined;
    saleUnit?: string | undefined;
    purchaseUnit?: string | undefined;
    alertQuantity?: number | undefined;
    barCodeType?: string | undefined;
    qrCodeType?: string | undefined;
    taxMethod?: TaxMethod;
    taxRate?: number;
    discountType?: DiscountType;
    discount?: number;
    description?: string | undefined;
    isActive?: boolean;
    photoUrls?: string[];
    optionsDataSources?: { [key: string]: any; };
}

export class GetProductListQuery extends DataGridModel implements IGetProductListQuery {
    cacheKey?: string;

    constructor(data?: IGetProductListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetProductListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetProductListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class ProductUpsertModel implements IProductUpsertModel {
    name?: string;
    categoryId?: string;
    productTypeId?: string;
    brandId?: string | undefined;
    code?: string | undefined;
    sku?: string | undefined;
    costPrice?: number | undefined;
    salePrice?: number;
    wholesalePrice?: number | undefined;
    unit?: string | undefined;
    saleUnit?: string | undefined;
    purchaseUnit?: string | undefined;
    alertQuantity?: number | undefined;
    barCodeType?: string | undefined;
    qrCodeType?: string | undefined;
    taxMethod?: TaxMethod;
    taxRate?: number;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductUpsertModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.categoryId = _data["categoryId"];
            this.productTypeId = _data["productTypeId"];
            this.brandId = _data["brandId"];
            this.code = _data["code"];
            this.sku = _data["sku"];
            this.costPrice = _data["costPrice"];
            this.salePrice = _data["salePrice"];
            this.wholesalePrice = _data["wholesalePrice"];
            this.unit = _data["unit"];
            this.saleUnit = _data["saleUnit"];
            this.purchaseUnit = _data["purchaseUnit"];
            this.alertQuantity = _data["alertQuantity"];
            this.barCodeType = _data["barCodeType"];
            this.qrCodeType = _data["qrCodeType"];
            this.taxMethod = _data["taxMethod"];
            this.taxRate = _data["taxRate"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductUpsertModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUpsertModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["productTypeId"] = this.productTypeId;
        data["brandId"] = this.brandId;
        data["code"] = this.code;
        data["sku"] = this.sku;
        data["costPrice"] = this.costPrice;
        data["salePrice"] = this.salePrice;
        data["wholesalePrice"] = this.wholesalePrice;
        data["unit"] = this.unit;
        data["saleUnit"] = this.saleUnit;
        data["purchaseUnit"] = this.purchaseUnit;
        data["alertQuantity"] = this.alertQuantity;
        data["barCodeType"] = this.barCodeType;
        data["qrCodeType"] = this.qrCodeType;
        data["taxMethod"] = this.taxMethod;
        data["taxRate"] = this.taxRate;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IProductUpsertModel {
    name?: string;
    categoryId?: string;
    productTypeId?: string;
    brandId?: string | undefined;
    code?: string | undefined;
    sku?: string | undefined;
    costPrice?: number | undefined;
    salePrice?: number;
    wholesalePrice?: number | undefined;
    unit?: string | undefined;
    saleUnit?: string | undefined;
    purchaseUnit?: string | undefined;
    alertQuantity?: number | undefined;
    barCodeType?: string | undefined;
    qrCodeType?: string | undefined;
    taxMethod?: TaxMethod;
    taxRate?: number;
    description?: string | undefined;
    isActive?: boolean;
}

export class CreateProductCommand extends ProductUpsertModel implements ICreateProductCommand {
    cacheKey?: string;

    constructor(data?: ICreateProductCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductCommand extends IProductUpsertModel {
    cacheKey?: string;
}

export class UpdateProductCommand extends ProductUpsertModel implements IUpdateProductCommand {
    id?: string;
    cacheKey?: string;

    constructor(data?: IUpdateProductCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductCommand extends IProductUpsertModel {
    id?: string;
    cacheKey?: string;
}

export class ProductSelectListModel implements IProductSelectListModel {
    id?: string;
    name?: string;
    code?: string | undefined;
    costPrice?: number | undefined;
    salePrice?: number;
    purchaseUnit?: string | undefined;
    saleUnit?: string | undefined;
    discountType?: DiscountType;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    taxRate?: number;
    taxMethod?: TaxMethod;

    constructor(data?: IProductSelectListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.costPrice = _data["costPrice"];
            this.salePrice = _data["salePrice"];
            this.purchaseUnit = _data["purchaseUnit"];
            this.saleUnit = _data["saleUnit"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
            this.discountRate = _data["discountRate"];
            this.taxRate = _data["taxRate"];
            this.taxMethod = _data["taxMethod"];
        }
    }

    static fromJS(data: any): ProductSelectListModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSelectListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["costPrice"] = this.costPrice;
        data["salePrice"] = this.salePrice;
        data["purchaseUnit"] = this.purchaseUnit;
        data["saleUnit"] = this.saleUnit;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        data["discountRate"] = this.discountRate;
        data["taxRate"] = this.taxRate;
        data["taxMethod"] = this.taxMethod;
        return data;
    }
}

export interface IProductSelectListModel {
    id?: string;
    name?: string;
    code?: string | undefined;
    costPrice?: number | undefined;
    salePrice?: number;
    purchaseUnit?: string | undefined;
    saleUnit?: string | undefined;
    discountType?: DiscountType;
    discountAmount?: number | undefined;
    discountRate?: number | undefined;
    taxRate?: number;
    taxMethod?: TaxMethod;
}

export class PaginatedResponseOfTaxModel implements IPaginatedResponseOfTaxModel {
    items?: TaxModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfTaxModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TaxModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfTaxModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfTaxModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfTaxModel {
    items?: TaxModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class TaxModel implements ITaxModel {
    id?: string;
    name?: string;
    rate?: number;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ITaxModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): TaxModel {
        data = typeof data === 'object' ? data : {};
        let result = new TaxModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ITaxModel {
    id?: string;
    name?: string;
    rate?: number;
    optionsDataSources?: { [key: string]: any; };
}

export class GetTaxListQuery extends DataGridModel implements IGetTaxListQuery {
    cacheKey?: string;

    constructor(data?: IGetTaxListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetTaxListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaxListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetTaxListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateTaxCommand implements ICreateTaxCommand {
    name?: string;
    rate?: number;
    cacheKey?: string;

    constructor(data?: ICreateTaxCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateTaxCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaxCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateTaxCommand {
    name?: string;
    rate?: number;
    cacheKey?: string;
}

export class UpdateTaxCommand implements IUpdateTaxCommand {
    id!: string;
    name?: string;
    rate?: number;
    cacheKey?: string;

    constructor(data?: IUpdateTaxCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateTaxCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaxCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateTaxCommand {
    id: string;
    name?: string;
    rate?: number;
    cacheKey?: string;
}

export class PaginatedResponseOfUnitModel implements IPaginatedResponseOfUnitModel {
    items?: UnitModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfUnitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UnitModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfUnitModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfUnitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfUnitModel {
    items?: UnitModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class UnitModel implements IUnitModel {
    id?: string;
    code?: string | undefined;
    name?: string;
    baseUnit?: string | undefined;
    operator?: string | undefined;
    operatorValue?: number | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IUnitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.baseUnit = _data["baseUnit"];
            this.operator = _data["operator"];
            this.operatorValue = _data["operatorValue"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): UnitModel {
        data = typeof data === 'object' ? data : {};
        let result = new UnitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["baseUnit"] = this.baseUnit;
        data["operator"] = this.operator;
        data["operatorValue"] = this.operatorValue;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IUnitModel {
    id?: string;
    code?: string | undefined;
    name?: string;
    baseUnit?: string | undefined;
    operator?: string | undefined;
    operatorValue?: number | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetUnitListQuery extends DataGridModel implements IGetUnitListQuery {
    cacheKey?: string;

    constructor(data?: IGetUnitListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetUnitListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnitListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetUnitListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateUnitCommand implements ICreateUnitCommand {
    code?: string | undefined;
    name?: string;
    baseUnit?: string | undefined;
    operator?: string | undefined;
    operatorValue?: number | undefined;
    cacheKey?: string;

    constructor(data?: ICreateUnitCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.baseUnit = _data["baseUnit"];
            this.operator = _data["operator"];
            this.operatorValue = _data["operatorValue"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateUnitCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUnitCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["baseUnit"] = this.baseUnit;
        data["operator"] = this.operator;
        data["operatorValue"] = this.operatorValue;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateUnitCommand {
    code?: string | undefined;
    name?: string;
    baseUnit?: string | undefined;
    operator?: string | undefined;
    operatorValue?: number | undefined;
    cacheKey?: string;
}

export class UpdateUnitCommand implements IUpdateUnitCommand {
    id!: string;
    code?: string | undefined;
    name?: string;
    baseUnit?: string | undefined;
    operator?: string | undefined;
    operatorValue?: number | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateUnitCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.baseUnit = _data["baseUnit"];
            this.operator = _data["operator"];
            this.operatorValue = _data["operatorValue"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateUnitCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUnitCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["baseUnit"] = this.baseUnit;
        data["operator"] = this.operator;
        data["operatorValue"] = this.operatorValue;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateUnitCommand {
    id: string;
    code?: string | undefined;
    name?: string;
    baseUnit?: string | undefined;
    operator?: string | undefined;
    operatorValue?: number | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfWarehouseModel implements IPaginatedResponseOfWarehouseModel {
    items?: WarehouseModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfWarehouseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WarehouseModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfWarehouseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfWarehouseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfWarehouseModel {
    items?: WarehouseModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class WarehouseModel implements IWarehouseModel {
    id?: string;
    name?: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    countryId?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    active?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IWarehouseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
            this.active = _data["active"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): WarehouseModel {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        data["active"] = this.active;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IWarehouseModel {
    id?: string;
    name?: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    countryId?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    active?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetWarehouseListQuery extends DataGridModel implements IGetWarehouseListQuery {
    cacheKey?: string;

    constructor(data?: IGetWarehouseListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetWarehouseListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarehouseListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetWarehouseListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateWarehouseCommand implements ICreateWarehouseCommand {
    name!: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    countryId?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateWarehouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.countryId = _data["countryId"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateWarehouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWarehouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["countryId"] = this.countryId;
        data["city"] = this.city;
        data["address"] = this.address;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateWarehouseCommand {
    name: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    countryId?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    cacheKey?: string;
}

export class UpdateWarehouseCommand implements IUpdateWarehouseCommand {
    id?: string;
    name!: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    countryId?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;

    constructor(data?: IUpdateWarehouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNo = _data["phoneNo"];
            this.mobile = _data["mobile"];
            this.countryId = _data["countryId"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateWarehouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWarehouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNo"] = this.phoneNo;
        data["mobile"] = this.mobile;
        data["countryId"] = this.countryId;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateWarehouseCommand {
    id?: string;
    name: string;
    email?: string | undefined;
    phoneNo?: string | undefined;
    mobile?: string | undefined;
    countryId?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
    cacheKey?: string;
}

export class PaginatedResponseOfLookupDetailModel implements IPaginatedResponseOfLookupDetailModel {
    items?: LookupDetailModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfLookupDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupDetailModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfLookupDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfLookupDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfLookupDetailModel {
    items?: LookupDetailModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class LookupDetailModel implements ILookupDetailModel {
    id?: string;
    name?: string;
    code?: string;
    description?: string;
    status?: boolean;
    statusName?: string;
    parentId?: string | undefined;
    parentName?: string;
    lookupId?: string | undefined;
    lookupName?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ILookupDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.parentId = _data["parentId"];
            this.parentName = _data["parentName"];
            this.lookupId = _data["lookupId"];
            this.lookupName = _data["lookupName"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): LookupDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["lookupId"] = this.lookupId;
        data["lookupName"] = this.lookupName;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ILookupDetailModel {
    id?: string;
    name?: string;
    code?: string;
    description?: string;
    status?: boolean;
    statusName?: string;
    parentId?: string | undefined;
    parentName?: string;
    lookupId?: string | undefined;
    lookupName?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetLookupDetailListQuery extends DataGridModel implements IGetLookupDetailListQuery {
    cacheKey?: string;

    constructor(data?: IGetLookupDetailListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetLookupDetailListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetLookupDetailListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetLookupDetailListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateLookupDetailCommand implements ICreateLookupDetailCommand {
    name!: string;
    code?: string;
    description?: string;
    status?: boolean;
    lookupId?: string;
    parentId?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateLookupDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.lookupId = _data["lookupId"];
            this.parentId = _data["parentId"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateLookupDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLookupDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["lookupId"] = this.lookupId;
        data["parentId"] = this.parentId;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateLookupDetailCommand {
    name: string;
    code?: string;
    description?: string;
    status?: boolean;
    lookupId?: string;
    parentId?: string | undefined;
    cacheKey?: string;
}

export class UpdateLookupDetailCommand implements IUpdateLookupDetailCommand {
    id?: string;
    name!: string;
    code?: string;
    description?: string;
    status?: boolean;
    lookupId!: string;
    parentId?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateLookupDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.lookupId = _data["lookupId"];
            this.parentId = _data["parentId"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateLookupDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLookupDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["lookupId"] = this.lookupId;
        data["parentId"] = this.parentId;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateLookupDetailCommand {
    id?: string;
    name: string;
    code?: string;
    description?: string;
    status?: boolean;
    lookupId: string;
    parentId?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfLookupModel implements IPaginatedResponseOfLookupModel {
    items?: LookupModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfLookupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfLookupModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfLookupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfLookupModel {
    items?: LookupModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class LookupModel implements ILookupModel {
    id?: string;
    name?: string;
    code?: string;
    description?: string;
    status?: boolean;
    statusName?: string;
    parentId?: string | undefined;
    parentName?: string;
    created?: Date | undefined;
    createdDate?: Date | undefined;
    createdTime?: string | undefined;
    createdYear?: number | undefined;
    subjects?: string[];
    subjectRadio?: string;
    color?: string;
    uploadFile?: string;
    descEdit?: string;
    menus?: string[];
    singleMenu?: string;
    treeSelectMenus?: string[];
    treeSelectSingleMenu?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: ILookupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.parentId = _data["parentId"];
            this.parentName = _data["parentName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdTime = _data["createdTime"];
            this.createdYear = _data["createdYear"];
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(item);
            }
            this.subjectRadio = _data["subjectRadio"];
            this.color = _data["color"];
            this.uploadFile = _data["uploadFile"];
            this.descEdit = _data["descEdit"];
            if (Array.isArray(_data["menus"])) {
                this.menus = [] as any;
                for (let item of _data["menus"])
                    this.menus!.push(item);
            }
            this.singleMenu = _data["singleMenu"];
            if (Array.isArray(_data["treeSelectMenus"])) {
                this.treeSelectMenus = [] as any;
                for (let item of _data["treeSelectMenus"])
                    this.treeSelectMenus!.push(item);
            }
            this.treeSelectSingleMenu = _data["treeSelectSingleMenu"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): LookupModel {
        data = typeof data === 'object' ? data : {};
        let result = new LookupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? formatDate(this.createdDate) : <any>undefined;
        data["createdTime"] = this.createdTime;
        data["createdYear"] = this.createdYear;
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item);
        }
        data["subjectRadio"] = this.subjectRadio;
        data["color"] = this.color;
        data["uploadFile"] = this.uploadFile;
        data["descEdit"] = this.descEdit;
        if (Array.isArray(this.menus)) {
            data["menus"] = [];
            for (let item of this.menus)
                data["menus"].push(item);
        }
        data["singleMenu"] = this.singleMenu;
        if (Array.isArray(this.treeSelectMenus)) {
            data["treeSelectMenus"] = [];
            for (let item of this.treeSelectMenus)
                data["treeSelectMenus"].push(item);
        }
        data["treeSelectSingleMenu"] = this.treeSelectSingleMenu;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface ILookupModel {
    id?: string;
    name?: string;
    code?: string;
    description?: string;
    status?: boolean;
    statusName?: string;
    parentId?: string | undefined;
    parentName?: string;
    created?: Date | undefined;
    createdDate?: Date | undefined;
    createdTime?: string | undefined;
    createdYear?: number | undefined;
    subjects?: string[];
    subjectRadio?: string;
    color?: string;
    uploadFile?: string;
    descEdit?: string;
    menus?: string[];
    singleMenu?: string;
    treeSelectMenus?: string[];
    treeSelectSingleMenu?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetLookupListQuery extends DataGridModel implements IGetLookupListQuery {

    constructor(data?: IGetLookupListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetLookupListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetLookupListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetLookupListQuery extends IDataGridModel {
}

export class CreateLookupCommand implements ICreateLookupCommand {
    name!: string;
    code!: string;
    description?: string;
    status?: boolean;
    parentId?: string | undefined;

    constructor(data?: ICreateLookupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateLookupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLookupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface ICreateLookupCommand {
    name: string;
    code: string;
    description?: string;
    status?: boolean;
    parentId?: string | undefined;
}

export class UpdateLookupCommand implements IUpdateLookupCommand {
    id?: string;
    name!: string;
    code!: string;
    description?: string;
    status?: boolean;
    parentId?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateLookupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.parentId = _data["parentId"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateLookupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLookupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["parentId"] = this.parentId;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateLookupCommand {
    id?: string;
    name: string;
    code: string;
    description?: string;
    status?: boolean;
    parentId?: string | undefined;
    cacheKey?: string;
}

export class PaginatedResponseOfAppMenuModel implements IPaginatedResponseOfAppMenuModel {
    items?: AppMenuModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfAppMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppMenuModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfAppMenuModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfAppMenuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfAppMenuModel {
    items?: AppMenuModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class AppMenuModel implements IAppMenuModel {
    id?: string;
    parentId?: string | undefined;
    parentName?: string;
    label?: string;
    routerLink?: string;
    icon?: string;
    tooltip?: string;
    isActive?: boolean;
    orderNo?: number;
    visible?: boolean;
    visibility?: string;
    description?: string;
    active?: string;
    menuTypeId?: string;
    menuTypeName?: string;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IAppMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.parentName = _data["parentName"];
            this.label = _data["label"];
            this.routerLink = _data["routerLink"];
            this.icon = _data["icon"];
            this.tooltip = _data["tooltip"];
            this.isActive = _data["isActive"];
            this.orderNo = _data["orderNo"];
            this.visible = _data["visible"];
            this.visibility = _data["visibility"];
            this.description = _data["description"];
            this.active = _data["active"];
            this.menuTypeId = _data["menuTypeId"];
            this.menuTypeName = _data["menuTypeName"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): AppMenuModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppMenuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["label"] = this.label;
        data["routerLink"] = this.routerLink;
        data["icon"] = this.icon;
        data["tooltip"] = this.tooltip;
        data["isActive"] = this.isActive;
        data["orderNo"] = this.orderNo;
        data["visible"] = this.visible;
        data["visibility"] = this.visibility;
        data["description"] = this.description;
        data["active"] = this.active;
        data["menuTypeId"] = this.menuTypeId;
        data["menuTypeName"] = this.menuTypeName;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IAppMenuModel {
    id?: string;
    parentId?: string | undefined;
    parentName?: string;
    label?: string;
    routerLink?: string;
    icon?: string;
    tooltip?: string;
    isActive?: boolean;
    orderNo?: number;
    visible?: boolean;
    visibility?: string;
    description?: string;
    active?: string;
    menuTypeId?: string;
    menuTypeName?: string;
    optionsDataSources?: { [key: string]: any; };
}

export class GetAppMenuListQuery extends DataGridModel implements IGetAppMenuListQuery {

    constructor(data?: IGetAppMenuListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetAppMenuListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppMenuListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetAppMenuListQuery extends IDataGridModel {
}

export class SidebarMenuModel implements ISidebarMenuModel {
    id?: string;
    label?: string;
    routerLink?: string;
    icon?: string;
    visible?: boolean;
    tooltip?: string;
    orderNo?: number;
    parentId?: string | undefined;
    parentLabel?: string;
    items?: SidebarMenuModel[] | undefined;

    constructor(data?: ISidebarMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.routerLink = _data["routerLink"];
            this.icon = _data["icon"];
            this.visible = _data["visible"];
            this.tooltip = _data["tooltip"];
            this.orderNo = _data["orderNo"];
            this.parentId = _data["parentId"];
            this.parentLabel = _data["parentLabel"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SidebarMenuModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SidebarMenuModel {
        data = typeof data === 'object' ? data : {};
        let result = new SidebarMenuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["routerLink"] = this.routerLink;
        data["icon"] = this.icon;
        data["visible"] = this.visible;
        data["tooltip"] = this.tooltip;
        data["orderNo"] = this.orderNo;
        data["parentId"] = this.parentId;
        data["parentLabel"] = this.parentLabel;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISidebarMenuModel {
    id?: string;
    label?: string;
    routerLink?: string;
    icon?: string;
    visible?: boolean;
    tooltip?: string;
    orderNo?: number;
    parentId?: string | undefined;
    parentLabel?: string;
    items?: SidebarMenuModel[] | undefined;
}

export class CreateAppMenuCommand implements ICreateAppMenuCommand {
    label!: string;
    routerLink!: string;
    icon?: string;
    isActive?: boolean;
    visible?: boolean;
    orderNo?: number;
    tooltip?: string;
    description?: string;
    menuTypeId!: string;
    parentId?: string | undefined;

    constructor(data?: ICreateAppMenuCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.routerLink = _data["routerLink"];
            this.icon = _data["icon"];
            this.isActive = _data["isActive"];
            this.visible = _data["visible"];
            this.orderNo = _data["orderNo"];
            this.tooltip = _data["tooltip"];
            this.description = _data["description"];
            this.menuTypeId = _data["menuTypeId"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateAppMenuCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppMenuCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["routerLink"] = this.routerLink;
        data["icon"] = this.icon;
        data["isActive"] = this.isActive;
        data["visible"] = this.visible;
        data["orderNo"] = this.orderNo;
        data["tooltip"] = this.tooltip;
        data["description"] = this.description;
        data["menuTypeId"] = this.menuTypeId;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface ICreateAppMenuCommand {
    label: string;
    routerLink: string;
    icon?: string;
    isActive?: boolean;
    visible?: boolean;
    orderNo?: number;
    tooltip?: string;
    description?: string;
    menuTypeId: string;
    parentId?: string | undefined;
}

export class UpdateAppMenuCommand implements IUpdateAppMenuCommand {
    id?: string;
    label!: string;
    routerLink!: string;
    icon?: string;
    isActive?: boolean;
    visible?: boolean;
    orderNo?: number;
    tooltip?: string;
    description?: string;
    menuTypeId!: string;
    parentId?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateAppMenuCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.routerLink = _data["routerLink"];
            this.icon = _data["icon"];
            this.isActive = _data["isActive"];
            this.visible = _data["visible"];
            this.orderNo = _data["orderNo"];
            this.tooltip = _data["tooltip"];
            this.description = _data["description"];
            this.menuTypeId = _data["menuTypeId"];
            this.parentId = _data["parentId"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateAppMenuCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppMenuCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["routerLink"] = this.routerLink;
        data["icon"] = this.icon;
        data["isActive"] = this.isActive;
        data["visible"] = this.visible;
        data["orderNo"] = this.orderNo;
        data["tooltip"] = this.tooltip;
        data["description"] = this.description;
        data["menuTypeId"] = this.menuTypeId;
        data["parentId"] = this.parentId;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateAppMenuCommand {
    id?: string;
    label: string;
    routerLink: string;
    icon?: string;
    isActive?: boolean;
    visible?: boolean;
    orderNo?: number;
    tooltip?: string;
    description?: string;
    menuTypeId: string;
    parentId?: string | undefined;
    cacheKey?: string;
}

export class UpdateAppMenuOrderCommand implements IUpdateAppMenuOrderCommand {
    reorderedAppMenus?: TreeNodeModel[];
    cacheKey?: string;

    constructor(data?: IUpdateAppMenuOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reorderedAppMenus"])) {
                this.reorderedAppMenus = [] as any;
                for (let item of _data["reorderedAppMenus"])
                    this.reorderedAppMenus!.push(TreeNodeModel.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateAppMenuOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppMenuOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reorderedAppMenus)) {
            data["reorderedAppMenus"] = [];
            for (let item of this.reorderedAppMenus)
                data["reorderedAppMenus"].push(item.toJSON());
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateAppMenuOrderCommand {
    reorderedAppMenus?: TreeNodeModel[];
    cacheKey?: string;
}

export class PaginatedResponseOfAppNotificationModel implements IPaginatedResponseOfAppNotificationModel {
    items?: AppNotificationModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfAppNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppNotificationModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfAppNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfAppNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfAppNotificationModel {
    items?: AppNotificationModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class AppNotificationModel implements IAppNotificationModel {
    id?: string;
    title?: string;
    description?: string | undefined;
    url?: string | undefined;
    senderId?: string;
    recieverId?: string;
    isSeen?: boolean;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IAppNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.senderId = _data["senderId"];
            this.recieverId = _data["recieverId"];
            this.isSeen = _data["isSeen"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): AppNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["url"] = this.url;
        data["senderId"] = this.senderId;
        data["recieverId"] = this.recieverId;
        data["isSeen"] = this.isSeen;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IAppNotificationModel {
    id?: string;
    title?: string;
    description?: string | undefined;
    url?: string | undefined;
    senderId?: string;
    recieverId?: string;
    isSeen?: boolean;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class GetAppNotificationListQuery extends DataGridModel implements IGetAppNotificationListQuery {

    constructor(data?: IGetAppNotificationListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetAppNotificationListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppNotificationListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetAppNotificationListQuery extends IDataGridModel {
}

export class PaginatedResponseOfAppPageModel implements IPaginatedResponseOfAppPageModel {
    items?: AppPageModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfAppPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPageModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfAppPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfAppPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfAppPageModel {
    items?: AppPageModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class AppPageModel implements IAppPageModel {
    id?: string;
    title?: string;
    subTitle?: string;
    componentName?: string;
    appPageLayout?: string;
    gridFilterType?: string;
    showRowActionCol?: boolean;
    rowActionType?: string | undefined;
    showSelectCheckbox?: boolean;
    appPageFields?: AppPageFieldModel[];
    toolbarActions?: AppPageActionModel[];
    rowActions?: AppPageActionModel[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IAppPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.componentName = _data["componentName"];
            this.appPageLayout = _data["appPageLayout"];
            this.gridFilterType = _data["gridFilterType"];
            this.showRowActionCol = _data["showRowActionCol"];
            this.rowActionType = _data["rowActionType"];
            this.showSelectCheckbox = _data["showSelectCheckbox"];
            if (Array.isArray(_data["appPageFields"])) {
                this.appPageFields = [] as any;
                for (let item of _data["appPageFields"])
                    this.appPageFields!.push(AppPageFieldModel.fromJS(item));
            }
            if (Array.isArray(_data["toolbarActions"])) {
                this.toolbarActions = [] as any;
                for (let item of _data["toolbarActions"])
                    this.toolbarActions!.push(AppPageActionModel.fromJS(item));
            }
            if (Array.isArray(_data["rowActions"])) {
                this.rowActions = [] as any;
                for (let item of _data["rowActions"])
                    this.rowActions!.push(AppPageActionModel.fromJS(item));
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): AppPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["componentName"] = this.componentName;
        data["appPageLayout"] = this.appPageLayout;
        data["gridFilterType"] = this.gridFilterType;
        data["showRowActionCol"] = this.showRowActionCol;
        data["rowActionType"] = this.rowActionType;
        data["showSelectCheckbox"] = this.showSelectCheckbox;
        if (Array.isArray(this.appPageFields)) {
            data["appPageFields"] = [];
            for (let item of this.appPageFields)
                data["appPageFields"].push(item.toJSON());
        }
        if (Array.isArray(this.toolbarActions)) {
            data["toolbarActions"] = [];
            for (let item of this.toolbarActions)
                data["toolbarActions"].push(item.toJSON());
        }
        if (Array.isArray(this.rowActions)) {
            data["rowActions"] = [];
            for (let item of this.rowActions)
                data["rowActions"].push(item.toJSON());
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IAppPageModel {
    id?: string;
    title?: string;
    subTitle?: string;
    componentName?: string;
    appPageLayout?: string;
    gridFilterType?: string;
    showRowActionCol?: boolean;
    rowActionType?: string | undefined;
    showSelectCheckbox?: boolean;
    appPageFields?: AppPageFieldModel[];
    toolbarActions?: AppPageActionModel[];
    rowActions?: AppPageActionModel[];
    optionsDataSources?: { [key: string]: any; };
}

export class AppPageFieldModel implements IAppPageFieldModel {
    id?: string;
    field?: string;
    header?: string;
    fieldType?: string;
    dbField?: string;
    format?: string;
    textAlign?: string;
    isSortable?: boolean;
    isFilterable?: boolean;
    dsName?: string;
    isGlobalFilterable?: boolean;
    filterType?: string;
    enableLink?: boolean;
    linkBaseUrl?: string;
    linkValueFieldName?: string;
    bgColor?: string;
    color?: string;
    tag?: string;
    isVisible?: boolean;
    sortOrder?: number;
    isActive?: boolean;

    constructor(data?: IAppPageFieldModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.field = _data["field"];
            this.header = _data["header"];
            this.fieldType = _data["fieldType"];
            this.dbField = _data["dbField"];
            this.format = _data["format"];
            this.textAlign = _data["textAlign"];
            this.isSortable = _data["isSortable"];
            this.isFilterable = _data["isFilterable"];
            this.dsName = _data["dsName"];
            this.isGlobalFilterable = _data["isGlobalFilterable"];
            this.filterType = _data["filterType"];
            this.enableLink = _data["enableLink"];
            this.linkBaseUrl = _data["linkBaseUrl"];
            this.linkValueFieldName = _data["linkValueFieldName"];
            this.bgColor = _data["bgColor"];
            this.color = _data["color"];
            this.tag = _data["tag"];
            this.isVisible = _data["isVisible"];
            this.sortOrder = _data["sortOrder"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AppPageFieldModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppPageFieldModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["field"] = this.field;
        data["header"] = this.header;
        data["fieldType"] = this.fieldType;
        data["dbField"] = this.dbField;
        data["format"] = this.format;
        data["textAlign"] = this.textAlign;
        data["isSortable"] = this.isSortable;
        data["isFilterable"] = this.isFilterable;
        data["dsName"] = this.dsName;
        data["isGlobalFilterable"] = this.isGlobalFilterable;
        data["filterType"] = this.filterType;
        data["enableLink"] = this.enableLink;
        data["linkBaseUrl"] = this.linkBaseUrl;
        data["linkValueFieldName"] = this.linkValueFieldName;
        data["bgColor"] = this.bgColor;
        data["color"] = this.color;
        data["tag"] = this.tag;
        data["isVisible"] = this.isVisible;
        data["sortOrder"] = this.sortOrder;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IAppPageFieldModel {
    id?: string;
    field?: string;
    header?: string;
    fieldType?: string;
    dbField?: string;
    format?: string;
    textAlign?: string;
    isSortable?: boolean;
    isFilterable?: boolean;
    dsName?: string;
    isGlobalFilterable?: boolean;
    filterType?: string;
    enableLink?: boolean;
    linkBaseUrl?: string;
    linkValueFieldName?: string;
    bgColor?: string;
    color?: string;
    tag?: string;
    isVisible?: boolean;
    sortOrder?: number;
    isActive?: boolean;
}

export class AppPageActionModel implements IAppPageActionModel {
    id?: string;
    actionName?: string;
    actionType?: string;
    severity?: string;
    permissions?: string;
    caption?: string;
    showCaption?: boolean;
    icon?: string;
    functionName?: string;
    navigationUrl?: string;
    params?: string;
    position?: string;
    parentId?: string | undefined;
    sortOrder?: number;
    isVisible?: boolean;

    constructor(data?: IAppPageActionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.actionName = _data["actionName"];
            this.actionType = _data["actionType"];
            this.severity = _data["severity"];
            this.permissions = _data["permissions"];
            this.caption = _data["caption"];
            this.showCaption = _data["showCaption"];
            this.icon = _data["icon"];
            this.functionName = _data["functionName"];
            this.navigationUrl = _data["navigationUrl"];
            this.params = _data["params"];
            this.position = _data["position"];
            this.parentId = _data["parentId"];
            this.sortOrder = _data["sortOrder"];
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): AppPageActionModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppPageActionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["actionName"] = this.actionName;
        data["actionType"] = this.actionType;
        data["severity"] = this.severity;
        data["permissions"] = this.permissions;
        data["caption"] = this.caption;
        data["showCaption"] = this.showCaption;
        data["icon"] = this.icon;
        data["functionName"] = this.functionName;
        data["navigationUrl"] = this.navigationUrl;
        data["params"] = this.params;
        data["position"] = this.position;
        data["parentId"] = this.parentId;
        data["sortOrder"] = this.sortOrder;
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IAppPageActionModel {
    id?: string;
    actionName?: string;
    actionType?: string;
    severity?: string;
    permissions?: string;
    caption?: string;
    showCaption?: boolean;
    icon?: string;
    functionName?: string;
    navigationUrl?: string;
    params?: string;
    position?: string;
    parentId?: string | undefined;
    sortOrder?: number;
    isVisible?: boolean;
}

export class GetAppPageListQuery extends DataGridModel implements IGetAppPageListQuery {

    constructor(data?: IGetAppPageListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetAppPageListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppPageListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetAppPageListQuery extends IDataGridModel {
}

export class CreateAppPageCommand implements ICreateAppPageCommand {
    title?: string;
    subTitle?: string;
    componentName?: string;
    appPageLayout?: string;
    cacheKey?: string;

    constructor(data?: ICreateAppPageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.componentName = _data["componentName"];
            this.appPageLayout = _data["appPageLayout"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateAppPageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppPageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["componentName"] = this.componentName;
        data["appPageLayout"] = this.appPageLayout;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateAppPageCommand {
    title?: string;
    subTitle?: string;
    componentName?: string;
    appPageLayout?: string;
    cacheKey?: string;
}

export class UpdateAppPageCommand implements IUpdateAppPageCommand {
    id?: string;
    title?: string;
    subTitle?: string;
    componentName?: string;
    appPageLayout?: string;
    cacheKey?: string;

    constructor(data?: IUpdateAppPageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.componentName = _data["componentName"];
            this.appPageLayout = _data["appPageLayout"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateAppPageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppPageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["componentName"] = this.componentName;
        data["appPageLayout"] = this.appPageLayout;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateAppPageCommand {
    id?: string;
    title?: string;
    subTitle?: string;
    componentName?: string;
    appPageLayout?: string;
    cacheKey?: string;
}

export class UpsertAppPageCommand extends AppPageModel implements IUpsertAppPageCommand {

    constructor(data?: IUpsertAppPageCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpsertAppPageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertAppPageCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertAppPageCommand extends IAppPageModel {
}

export class FileResponse implements IFileResponse {
    filePath?: string;

    constructor(data?: IFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filePath = _data["filePath"];
        }
    }

    static fromJS(data: any): FileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filePath"] = this.filePath;
        return data;
    }
}

export interface IFileResponse {
    filePath?: string;
}

export class RemoveFileRequest implements IRemoveFileRequest {
    relativePath?: string;

    constructor(data?: IRemoveFileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relativePath = _data["relativePath"];
        }
    }

    static fromJS(data: any): RemoveFileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveFileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relativePath"] = this.relativePath;
        return data;
    }
}

export interface IRemoveFileRequest {
    relativePath?: string;
}

export class PaginatedResponseOfRoleModel implements IPaginatedResponseOfRoleModel {
    items?: RoleModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfRoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfRoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfRoleModel {
    items?: RoleModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class RoleModel implements IRoleModel {
    id?: string;
    name?: string;
    roleMenus?: string[];
    permissions?: string[];
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["roleMenus"])) {
                this.roleMenus = [] as any;
                for (let item of _data["roleMenus"])
                    this.roleMenus!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): RoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.roleMenus)) {
            data["roleMenus"] = [];
            for (let item of this.roleMenus)
                data["roleMenus"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IRoleModel {
    id?: string;
    name?: string;
    roleMenus?: string[];
    permissions?: string[];
    optionsDataSources?: { [key: string]: any; };
}

export class GetRoleListQuery extends DataGridModel implements IGetRoleListQuery {

    constructor(data?: IGetRoleListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetRoleListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetRoleListQuery extends IDataGridModel {
}

export class CreateRoleCommand implements ICreateRoleCommand {
    name?: string;
    rolemenus?: string[];
    permissions?: string[];

    constructor(data?: ICreateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["rolemenus"])) {
                this.rolemenus = [] as any;
                for (let item of _data["rolemenus"])
                    this.rolemenus!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.rolemenus)) {
            data["rolemenus"] = [];
            for (let item of this.rolemenus)
                data["rolemenus"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface ICreateRoleCommand {
    name?: string;
    rolemenus?: string[];
    permissions?: string[];
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    id?: string;
    name?: string;
    rolemenus?: string[];
    permissions?: string[];

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["rolemenus"])) {
                this.rolemenus = [] as any;
                for (let item of _data["rolemenus"])
                    this.rolemenus!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.rolemenus)) {
            data["rolemenus"] = [];
            for (let item of this.rolemenus)
                data["rolemenus"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IUpdateRoleCommand {
    id?: string;
    name?: string;
    rolemenus?: string[];
    permissions?: string[];
}

export class PaginatedResponseOfAppUserModel implements IPaginatedResponseOfAppUserModel {
    items?: AppUserModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfAppUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppUserModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfAppUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfAppUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfAppUserModel {
    items?: AppUserModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class AppUserModel implements IAppUserModel {
    id?: string;
    username?: string;
    password?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string | undefined;
    photoUrl?: string | undefined;
    isActive?: boolean;
    status?: string;
    assignedRoles?: string;
    optionsDataSources?: { [key: string]: any; };
    roles?: string[] | undefined;

    constructor(data?: IAppUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.photoUrl = _data["photoUrl"];
            this.isActive = _data["isActive"];
            this.status = _data["status"];
            this.assignedRoles = _data["assignedRoles"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AppUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["photoUrl"] = this.photoUrl;
        data["isActive"] = this.isActive;
        data["status"] = this.status;
        data["assignedRoles"] = this.assignedRoles;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IAppUserModel {
    id?: string;
    username?: string;
    password?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string | undefined;
    photoUrl?: string | undefined;
    isActive?: boolean;
    status?: string;
    assignedRoles?: string;
    optionsDataSources?: { [key: string]: any; };
    roles?: string[] | undefined;
}

export class GetAppUserListQuery extends DataGridModel implements IGetAppUserListQuery {

    constructor(data?: IGetAppUserListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetAppUserListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppUserListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetAppUserListQuery extends IDataGridModel {
}

export class CreateAppUserCommand implements ICreateAppUserCommand {
    username!: string;
    password!: string;
    email?: string;
    firstName!: string;
    lastName!: string;
    phoneNumber?: string;
    photoUrl?: string;
    isActive?: boolean;
    roles?: string[] | undefined;

    constructor(data?: ICreateAppUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.photoUrl = _data["photoUrl"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAppUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["photoUrl"] = this.photoUrl;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateAppUserCommand {
    username: string;
    password: string;
    email?: string;
    firstName: string;
    lastName: string;
    phoneNumber?: string;
    photoUrl?: string;
    isActive?: boolean;
    roles?: string[] | undefined;
}

export class UpdateAppUserCommand implements IUpdateAppUserCommand {
    id?: string;
    username?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    isActive?: boolean;
    roles?: string[] | undefined;

    constructor(data?: IUpdateAppUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateAppUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUpdateAppUserCommand {
    id?: string;
    username?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    isActive?: boolean;
    roles?: string[] | undefined;
}

export class ChangeUserPhotoCommand implements IChangeUserPhotoCommand {
    photoUrl?: string;

    constructor(data?: IChangeUserPhotoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.photoUrl = _data["photoUrl"];
        }
    }

    static fromJS(data: any): ChangeUserPhotoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserPhotoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photoUrl"] = this.photoUrl;
        return data;
    }
}

export interface IChangeUserPhotoCommand {
    photoUrl?: string;
}

export class UpdateAppUserBasicCommand implements IUpdateAppUserBasicCommand {
    id?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;

    constructor(data?: IUpdateAppUserBasicCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateAppUserBasicCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppUserBasicCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IUpdateAppUserBasicCommand {
    id?: string;
    email?: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
}

export class AddToRolesCommand implements IAddToRolesCommand {
    id?: string;
    roleNames?: string[];

    constructor(data?: IAddToRolesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): AddToRolesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddToRolesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }
}

export interface IAddToRolesCommand {
    id?: string;
    roleNames?: string[];
}

export class PaginatedResponseOfExpenseModel implements IPaginatedResponseOfExpenseModel {
    items?: ExpenseModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IPaginatedResponseOfExpenseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExpenseModel.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaginatedResponseOfExpenseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseOfExpenseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IPaginatedResponseOfExpenseModel {
    items?: ExpenseModel[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    optionsDataSources?: { [key: string]: any; };
}

export class ExpenseModel implements IExpenseModel {
    id?: string;
    expenseDate?: Date;
    title?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    categoryId?: string;
    amount?: number;
    accountId?: string;
    description?: string | undefined;
    attachmentUrl?: string | undefined;
    optionsDataSources?: { [key: string]: any; };

    constructor(data?: IExpenseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expenseDate = _data["expenseDate"] ? new Date(_data["expenseDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.categoryId = _data["categoryId"];
            this.amount = _data["amount"];
            this.accountId = _data["accountId"];
            this.description = _data["description"];
            this.attachmentUrl = _data["attachmentUrl"];
            if (_data["optionsDataSources"]) {
                this.optionsDataSources = {} as any;
                for (let key in _data["optionsDataSources"]) {
                    if (_data["optionsDataSources"].hasOwnProperty(key))
                        (<any>this.optionsDataSources)![key] = _data["optionsDataSources"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExpenseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expenseDate"] = this.expenseDate ? this.expenseDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["categoryId"] = this.categoryId;
        data["amount"] = this.amount;
        data["accountId"] = this.accountId;
        data["description"] = this.description;
        data["attachmentUrl"] = this.attachmentUrl;
        if (this.optionsDataSources) {
            data["optionsDataSources"] = {};
            for (let key in this.optionsDataSources) {
                if (this.optionsDataSources.hasOwnProperty(key))
                    (<any>data["optionsDataSources"])[key] = (<any>this.optionsDataSources)[key];
            }
        }
        return data;
    }
}

export interface IExpenseModel {
    id?: string;
    expenseDate?: Date;
    title?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    categoryId?: string;
    amount?: number;
    accountId?: string;
    description?: string | undefined;
    attachmentUrl?: string | undefined;
    optionsDataSources?: { [key: string]: any; };
}

export class GetExpenseListQuery extends DataGridModel implements IGetExpenseListQuery {
    cacheKey?: string;

    constructor(data?: IGetExpenseListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheKey = _data["cacheKey"];
        }
    }

    static override fromJS(data: any): GetExpenseListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpenseListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheKey"] = this.cacheKey;
        super.toJSON(data);
        return data;
    }
}

export interface IGetExpenseListQuery extends IDataGridModel {
    cacheKey?: string;
}

export class CreateExpenseCommand implements ICreateExpenseCommand {
    expenseDate?: Date;
    title?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    categoryId?: string;
    amount?: number;
    accountId?: string;
    description?: string | undefined;
    attachmentUrl?: string | undefined;
    cacheKey?: string;

    constructor(data?: ICreateExpenseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseDate = _data["expenseDate"] ? new Date(_data["expenseDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.categoryId = _data["categoryId"];
            this.amount = _data["amount"];
            this.accountId = _data["accountId"];
            this.description = _data["description"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CreateExpenseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExpenseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseDate"] = this.expenseDate ? this.expenseDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["categoryId"] = this.categoryId;
        data["amount"] = this.amount;
        data["accountId"] = this.accountId;
        data["description"] = this.description;
        data["attachmentUrl"] = this.attachmentUrl;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICreateExpenseCommand {
    expenseDate?: Date;
    title?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    categoryId?: string;
    amount?: number;
    accountId?: string;
    description?: string | undefined;
    attachmentUrl?: string | undefined;
    cacheKey?: string;
}

export class UpdateExpenseCommand implements IUpdateExpenseCommand {
    id!: string;
    expenseDate?: Date;
    title?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    categoryId?: string;
    amount?: number;
    accountId?: string;
    description?: string | undefined;
    attachmentUrl?: string | undefined;
    cacheKey?: string;

    constructor(data?: IUpdateExpenseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expenseDate = _data["expenseDate"] ? new Date(_data["expenseDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.referenceNo = _data["referenceNo"];
            this.warehouseId = _data["warehouseId"];
            this.categoryId = _data["categoryId"];
            this.amount = _data["amount"];
            this.accountId = _data["accountId"];
            this.description = _data["description"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UpdateExpenseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExpenseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expenseDate"] = this.expenseDate ? this.expenseDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["referenceNo"] = this.referenceNo;
        data["warehouseId"] = this.warehouseId;
        data["categoryId"] = this.categoryId;
        data["amount"] = this.amount;
        data["accountId"] = this.accountId;
        data["description"] = this.description;
        data["attachmentUrl"] = this.attachmentUrl;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUpdateExpenseCommand {
    id: string;
    expenseDate?: Date;
    title?: string | undefined;
    referenceNo?: string | undefined;
    warehouseId?: string;
    categoryId?: string;
    amount?: number;
    accountId?: string;
    description?: string | undefined;
    attachmentUrl?: string | undefined;
    cacheKey?: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class LMSException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isLMSException = true;

    static isLMSException(obj: any): obj is LMSException {
        return obj.isLMSException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new LMSException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}